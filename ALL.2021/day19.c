#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <assert.h>
#include <map>
#include <iostream>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <algorithm> 

using namespace std;
//deque <int> b1Q;
int other = 0;

FILE *a;
#define LINE 1000
#define getchar()
//f(char*s){for(s+=9;(*s+=*s-57?1:8)>90;*s--=48);}
//char var_orient[] = "0000000000";
struct al_s {
	int p1b2;
	int p2b2;
};
struct al_s al[3000];
int alPos = 0;

map <tuple<int, int, int>, int> mp2;
///////////////////
unordered_set<int> vis;
unordered_map<int, vector<int>> adj;
int pairZ();
void dfs(int u, vector<int>& cur_group);
///////////////////

void next(char *as); int numit(int pos);
int lineI[10][32];
int lineI2[32];
long lineIPos = 0;
struct beacon_s {
	int scannerx;
	int scannery;
	int scannerz;

	int mapx;
	int mapy;
	int mapz;

	int orient;

	int x[50][25];
	int y[50][25];
	int z[50][25];

	/// should really switch the 25s
	int distxx[25][50][50];
	int distyy[25][50][50];
	int distzz[25][50][50];

	int beaconPos;
};
struct done_s {
	int bea;
};
int beaPos = 0;

struct pairs_s {
	int b1;
	int b2;
	int o1;
	int o2;
};
int same(int o1, int o2);
/////////////////////////////////////////
struct pairs_s pairs[] =
{
{ 0, 2, 0, 16},
{ 0, 2, 1, 17},
{ 0, 2, 2, 18},
{ 0, 2, 3, 19},
{ 0, 2, 4, 20},
{ 0, 2, 5, 21},
{ 0, 2, 6, 22},
{ 0, 2, 7, 23},
{ 0, 2, 8, 4},
{ 0, 2, 9, 5},
{ 0, 2, 10, 6},
{ 0, 2, 11, 7},
{ 0, 2, 12, 0},
{ 0, 2, 13, 1},
{ 0, 2, 14, 2},
{ 0, 2, 15, 3},
{ 0, 2, 16, 12},
{ 0, 2, 17, 13},
{ 0, 2, 18, 14},
{ 0, 2, 19, 15},
{ 0, 2, 20, 8},
{ 0, 2, 21, 9},
{ 0, 2, 22, 10},
{ 0, 2, 23, 11},
{ 0, 3, 0, 1},
{ 0, 3, 1, 0},
{ 0, 3, 2, 3},
{ 0, 3, 3, 2},
{ 0, 3, 4, 5},
{ 0, 3, 5, 4},
{ 0, 3, 6, 7},
{ 0, 3, 7, 6},
{ 0, 3, 8, 10},
{ 0, 3, 9, 11},
{ 0, 3, 10, 8},
{ 0, 3, 11, 9},
{ 0, 3, 12, 15},
{ 0, 3, 13, 14},
{ 0, 3, 14, 13},
{ 0, 3, 15, 12},
{ 0, 3, 16, 18},
{ 0, 3, 17, 19},
{ 0, 3, 18, 16},
{ 0, 3, 19, 17},
{ 0, 3, 20, 23},
{ 0, 3, 21, 22},
{ 0, 3, 22, 21},
{ 0, 3, 23, 20},
{ 0, 4, 0, 15},
{ 0, 4, 1, 14},
{ 0, 4, 2, 13},
{ 0, 4, 3, 12},
{ 0, 4, 4, 10},
{ 0, 4, 5, 11},
{ 0, 4, 6, 8},
{ 0, 4, 7, 9},
{ 0, 4, 8, 23},
{ 0, 4, 9, 22},
{ 0, 4, 10, 21},
{ 0, 4, 11, 20},
{ 0, 4, 12, 18},
{ 0, 4, 13, 19},
{ 0, 4, 14, 16},
{ 0, 4, 15, 17},
{ 0, 4, 16, 1},
{ 0, 4, 17, 0},
{ 0, 4, 18, 3},
{ 0, 4, 19, 2},
{ 0, 4, 20, 5},
{ 0, 4, 21, 4},
{ 0, 4, 22, 7},
{ 0, 4, 23, 6},
{ 0, 18, 0, 22},
{ 0, 18, 1, 23},
{ 0, 18, 2, 20},
{ 0, 18, 3, 21},
{ 0, 18, 4, 18},
{ 0, 18, 5, 19},
{ 0, 18, 6, 16},
{ 0, 18, 7, 17},
{ 0, 18, 8, 13},
{ 0, 18, 9, 12},
{ 0, 18, 10, 15},
{ 0, 18, 11, 14},
{ 0, 18, 12, 8},
{ 0, 18, 13, 9},
{ 0, 18, 14, 10},
{ 0, 18, 15, 11},
{ 0, 18, 16, 5},
{ 0, 18, 17, 4},
{ 0, 18, 18, 7},
{ 0, 18, 19, 6},
{ 0, 18, 20, 0},
{ 0, 18, 21, 1},
{ 0, 18, 22, 2},
{ 0, 18, 23, 3},
{ 0, 27, 0, 21},
{ 0, 27, 1, 20},
{ 0, 27, 2, 23},
{ 0, 27, 3, 22},
{ 0, 27, 4, 16},
{ 0, 27, 5, 17},
{ 0, 27, 6, 18},
{ 0, 27, 7, 19},
{ 0, 27, 8, 14},
{ 0, 27, 9, 15},
{ 0, 27, 10, 12},
{ 0, 27, 11, 13},
{ 0, 27, 12, 10},
{ 0, 27, 13, 11},
{ 0, 27, 14, 8},
{ 0, 27, 15, 9},
{ 0, 27, 16, 4},
{ 0, 27, 17, 5},
{ 0, 27, 18, 6},
{ 0, 27, 19, 7},
{ 0, 27, 20, 1},
{ 0, 27, 21, 0},
{ 0, 27, 22, 3},
{ 0, 27, 23, 2},
{ 1, 2, 0, 19},
{ 1, 2, 1, 18},
{ 1, 2, 2, 17},
{ 1, 2, 3, 16},
{ 1, 2, 4, 22},
{ 1, 2, 5, 23},
{ 1, 2, 6, 20},
{ 1, 2, 7, 21},
{ 1, 2, 8, 7},
{ 1, 2, 9, 6},
{ 1, 2, 10, 5},
{ 1, 2, 11, 4},
{ 1, 2, 12, 2},
{ 1, 2, 13, 3},
{ 1, 2, 14, 0},
{ 1, 2, 15, 1},
{ 1, 2, 16, 13},
{ 1, 2, 17, 12},
{ 1, 2, 18, 15},
{ 1, 2, 19, 14},
{ 1, 2, 20, 9},
{ 1, 2, 21, 8},
{ 1, 2, 22, 11},
{ 1, 2, 23, 10},
{ 1, 4, 0, 12},
{ 1, 4, 1, 13},
{ 1, 4, 2, 14},
{ 1, 4, 3, 15},
{ 1, 4, 4, 8},
{ 1, 4, 5, 9},
{ 1, 4, 6, 10},
{ 1, 4, 7, 11},
{ 1, 4, 8, 20},
{ 1, 4, 9, 21},
{ 1, 4, 10, 22},
{ 1, 4, 11, 23},
{ 1, 4, 12, 16},
{ 1, 4, 13, 17},
{ 1, 4, 14, 18},
{ 1, 4, 15, 19},
{ 1, 4, 16, 0},
{ 1, 4, 17, 1},
{ 1, 4, 18, 2},
{ 1, 4, 19, 3},
{ 1, 4, 20, 4},
{ 1, 4, 21, 5},
{ 1, 4, 22, 6},
{ 1, 4, 23, 7},
{ 2, 9, 0, 17},
{ 2, 9, 1, 16},
{ 2, 9, 2, 19},
{ 2, 9, 3, 18},
{ 2, 9, 4, 21},
{ 2, 9, 5, 20},
{ 2, 9, 6, 23},
{ 2, 9, 7, 22},
{ 2, 9, 8, 6},
{ 2, 9, 9, 7},
{ 2, 9, 10, 4},
{ 2, 9, 11, 5},
{ 2, 9, 12, 3},
{ 2, 9, 13, 2},
{ 2, 9, 14, 1},
{ 2, 9, 15, 0},
{ 2, 9, 16, 14},
{ 2, 9, 17, 15},
{ 2, 9, 18, 12},
{ 2, 9, 19, 13},
{ 2, 9, 20, 11},
{ 2, 9, 21, 10},
{ 2, 9, 22, 9},
{ 2, 9, 23, 8},
{ 3, 8, 0, 4},
{ 3, 8, 1, 5},
{ 3, 8, 2, 6},
{ 3, 8, 3, 7},
{ 3, 8, 4, 1},
{ 3, 8, 5, 0},
{ 3, 8, 6, 3},
{ 3, 8, 7, 2},
{ 3, 8, 8, 16},
{ 3, 8, 9, 17},
{ 3, 8, 10, 18},
{ 3, 8, 11, 19},
{ 3, 8, 12, 21},
{ 3, 8, 13, 20},
{ 3, 8, 14, 23},
{ 3, 8, 15, 22},
{ 3, 8, 16, 10},
{ 3, 8, 17, 11},
{ 3, 8, 18, 8},
{ 3, 8, 19, 9},
{ 3, 8, 20, 14},
{ 3, 8, 21, 15},
{ 3, 8, 22, 12},
{ 3, 8, 23, 13},
{ 4, 6, 0, 18},
{ 4, 6, 1, 19},
{ 4, 6, 2, 16},
{ 4, 6, 3, 17},
{ 4, 6, 4, 23},
{ 4, 6, 5, 22},
{ 4, 6, 6, 21},
{ 4, 6, 7, 20},
{ 4, 6, 8, 5},
{ 4, 6, 9, 4},
{ 4, 6, 10, 7},
{ 4, 6, 11, 6},
{ 4, 6, 12, 1},
{ 4, 6, 13, 0},
{ 4, 6, 14, 3},
{ 4, 6, 15, 2},
{ 4, 6, 16, 15},
{ 4, 6, 17, 14},
{ 4, 6, 18, 13},
{ 4, 6, 19, 12},
{ 4, 6, 20, 10},
{ 4, 6, 21, 11},
{ 4, 6, 22, 8},
{ 4, 6, 23, 9},
{ 4, 8, 0, 9},
{ 4, 8, 1, 8},
{ 4, 8, 2, 11},
{ 4, 8, 3, 10},
{ 4, 8, 4, 12},
{ 4, 8, 5, 13},
{ 4, 8, 6, 14},
{ 4, 8, 7, 15},
{ 4, 8, 8, 2},
{ 4, 8, 9, 3},
{ 4, 8, 10, 0},
{ 4, 8, 11, 1},
{ 4, 8, 12, 6},
{ 4, 8, 13, 7},
{ 4, 8, 14, 4},
{ 4, 8, 15, 5},
{ 4, 8, 16, 20},
{ 4, 8, 17, 21},
{ 4, 8, 18, 22},
{ 4, 8, 19, 23},
{ 4, 8, 20, 17},
{ 4, 8, 21, 16},
{ 4, 8, 22, 19},
{ 4, 8, 23, 18},
{ 4, 19, 0, 3},
{ 4, 19, 1, 2},
{ 4, 19, 2, 1},
{ 4, 19, 3, 0},
{ 4, 19, 4, 6},
{ 4, 19, 5, 7},
{ 4, 19, 6, 4},
{ 4, 19, 7, 5},
{ 4, 19, 8, 11},
{ 4, 19, 9, 10},
{ 4, 19, 10, 9},
{ 4, 19, 11, 8},
{ 4, 19, 12, 14},
{ 4, 19, 13, 15},
{ 4, 19, 14, 12},
{ 4, 19, 15, 13},
{ 4, 19, 16, 17},
{ 4, 19, 17, 16},
{ 4, 19, 18, 19},
{ 4, 19, 19, 18},
{ 4, 19, 20, 21},
{ 4, 19, 21, 20},
{ 4, 19, 22, 23},
{ 4, 19, 23, 22},
{ 4, 23, 0, 10},
{ 4, 23, 1, 11},
{ 4, 23, 2, 8},
{ 4, 23, 3, 9},
{ 4, 23, 4, 14},
{ 4, 23, 5, 15},
{ 4, 23, 6, 12},
{ 4, 23, 7, 13},
{ 4, 23, 8, 1},
{ 4, 23, 9, 0},
{ 4, 23, 10, 3},
{ 4, 23, 11, 2},
{ 4, 23, 12, 4},
{ 4, 23, 13, 5},
{ 4, 23, 14, 6},
{ 4, 23, 15, 7},
{ 4, 23, 16, 21},
{ 4, 23, 17, 20},
{ 4, 23, 18, 23},
{ 4, 23, 19, 22},
{ 4, 23, 20, 16},
{ 4, 23, 21, 17},
{ 4, 23, 22, 18},
{ 4, 23, 23, 19},
{ 5, 15, 0, 12},
{ 5, 15, 1, 13},
{ 5, 15, 2, 14},
{ 5, 15, 3, 15},
{ 5, 15, 4, 8},
{ 5, 15, 5, 9},
{ 5, 15, 6, 10},
{ 5, 15, 7, 11},
{ 5, 15, 8, 20},
{ 5, 15, 9, 21},
{ 5, 15, 10, 22},
{ 5, 15, 11, 23},
{ 5, 15, 12, 16},
{ 5, 15, 13, 17},
{ 5, 15, 14, 18},
{ 5, 15, 15, 19},
{ 5, 15, 16, 0},
{ 5, 15, 17, 1},
{ 5, 15, 18, 2},
{ 5, 15, 19, 3},
{ 5, 15, 20, 4},
{ 5, 15, 21, 5},
{ 5, 15, 22, 6},
{ 5, 15, 23, 7},
{ 5, 28, 0, 0},
{ 5, 28, 1, 1},
{ 5, 28, 2, 2},
{ 5, 28, 3, 3},
{ 5, 28, 4, 4},
{ 5, 28, 5, 5},
{ 5, 28, 6, 6},
{ 5, 28, 7, 7},
{ 5, 28, 8, 8},
{ 5, 28, 9, 9},
{ 5, 28, 10, 10},
{ 5, 28, 11, 11},
{ 5, 28, 12, 12},
{ 5, 28, 13, 13},
{ 5, 28, 14, 14},
{ 5, 28, 15, 15},
{ 5, 28, 16, 16},
{ 5, 28, 17, 17},
{ 5, 28, 18, 18},
{ 5, 28, 19, 19},
{ 5, 28, 20, 20},
{ 5, 28, 21, 21},
{ 5, 28, 22, 22},
{ 5, 28, 23, 23},
{ 6, 12, 0, 14},
{ 6, 12, 1, 15},
{ 6, 12, 2, 12},
{ 6, 12, 3, 13},
{ 6, 12, 4, 11},
{ 6, 12, 5, 10},
{ 6, 12, 6, 9},
{ 6, 12, 7, 8},
{ 6, 12, 8, 21},
{ 6, 12, 9, 20},
{ 6, 12, 10, 23},
{ 6, 12, 11, 22},
{ 6, 12, 12, 17},
{ 6, 12, 13, 16},
{ 6, 12, 14, 19},
{ 6, 12, 15, 18},
{ 6, 12, 16, 3},
{ 6, 12, 17, 2},
{ 6, 12, 18, 1},
{ 6, 12, 19, 0},
{ 6, 12, 20, 6},
{ 6, 12, 21, 7},
{ 6, 12, 22, 4},
{ 6, 12, 23, 5},
{ 6, 25, 0, 13},
{ 6, 25, 1, 12},
{ 6, 25, 2, 15},
{ 6, 25, 3, 14},
{ 6, 25, 4, 9},
{ 6, 25, 5, 8},
{ 6, 25, 6, 11},
{ 6, 25, 7, 10},
{ 6, 25, 8, 22},
{ 6, 25, 9, 23},
{ 6, 25, 10, 20},
{ 6, 25, 11, 21},
{ 6, 25, 12, 19},
{ 6, 25, 13, 18},
{ 6, 25, 14, 17},
{ 6, 25, 15, 16},
{ 6, 25, 16, 2},
{ 6, 25, 17, 3},
{ 6, 25, 18, 0},
{ 6, 25, 19, 1},
{ 6, 25, 20, 7},
{ 6, 25, 21, 6},
{ 6, 25, 22, 5},
{ 6, 25, 23, 4},
{ 7, 10, 0, 17},
{ 7, 10, 1, 16},
{ 7, 10, 2, 19},
{ 7, 10, 3, 18},
{ 7, 10, 4, 21},
{ 7, 10, 5, 20},
{ 7, 10, 6, 23},
{ 7, 10, 7, 22},
{ 7, 10, 8, 6},
{ 7, 10, 9, 7},
{ 7, 10, 10, 4},
{ 7, 10, 11, 5},
{ 7, 10, 12, 3},
{ 7, 10, 13, 2},
{ 7, 10, 14, 1},
{ 7, 10, 15, 0},
{ 7, 10, 16, 14},
{ 7, 10, 17, 15},
{ 7, 10, 18, 12},
{ 7, 10, 19, 13},
{ 7, 10, 20, 11},
{ 7, 10, 21, 10},
{ 7, 10, 22, 9},
{ 7, 10, 23, 8},
{ 7, 13, 0, 3},
{ 7, 13, 1, 2},
{ 7, 13, 2, 1},
{ 7, 13, 3, 0},
{ 7, 13, 4, 6},
{ 7, 13, 5, 7},
{ 7, 13, 6, 4},
{ 7, 13, 7, 5},
{ 7, 13, 8, 11},
{ 7, 13, 9, 10},
{ 7, 13, 10, 9},
{ 7, 13, 11, 8},
{ 7, 13, 12, 14},
{ 7, 13, 13, 15},
{ 7, 13, 14, 12},
{ 7, 13, 15, 13},
{ 7, 13, 16, 17},
{ 7, 13, 17, 16},
{ 7, 13, 18, 19},
{ 7, 13, 19, 18},
{ 7, 13, 20, 21},
{ 7, 13, 21, 20},
{ 7, 13, 22, 23},
{ 7, 13, 23, 22},
{ 7, 16, 0, 14},
{ 7, 16, 1, 15},
{ 7, 16, 2, 12},
{ 7, 16, 3, 13},
{ 7, 16, 4, 11},
{ 7, 16, 5, 10},
{ 7, 16, 6, 9},
{ 7, 16, 7, 8},
{ 7, 16, 8, 21},
{ 7, 16, 9, 20},
{ 7, 16, 10, 23},
{ 7, 16, 11, 22},
{ 7, 16, 12, 17},
{ 7, 16, 13, 16},
{ 7, 16, 14, 19},
{ 7, 16, 15, 18},
{ 7, 16, 16, 3},
{ 7, 16, 17, 2},
{ 7, 16, 18, 1},
{ 7, 16, 19, 0},
{ 7, 16, 20, 6},
{ 7, 16, 21, 7},
{ 7, 16, 22, 4},
{ 7, 16, 23, 5},
{ 7, 26, 0, 14},
{ 7, 26, 1, 15},
{ 7, 26, 2, 12},
{ 7, 26, 3, 13},
{ 7, 26, 4, 11},
{ 7, 26, 5, 10},
{ 7, 26, 6, 9},
{ 7, 26, 7, 8},
{ 7, 26, 8, 21},
{ 7, 26, 9, 20},
{ 7, 26, 10, 23},
{ 7, 26, 11, 22},
{ 7, 26, 12, 17},
{ 7, 26, 13, 16},
{ 7, 26, 14, 19},
{ 7, 26, 15, 18},
{ 7, 26, 16, 3},
{ 7, 26, 17, 2},
{ 7, 26, 18, 1},
{ 7, 26, 19, 0},
{ 7, 26, 20, 6},
{ 7, 26, 21, 7},
{ 7, 26, 22, 4},
{ 7, 26, 23, 5},
{ 8, 12, 0, 8},
{ 8, 12, 1, 9},
{ 8, 12, 2, 10},
{ 8, 12, 3, 11},
{ 8, 12, 4, 13},
{ 8, 12, 5, 12},
{ 8, 12, 6, 15},
{ 8, 12, 7, 14},
{ 8, 12, 8, 0},
{ 8, 12, 9, 1},
{ 8, 12, 10, 2},
{ 8, 12, 11, 3},
{ 8, 12, 12, 5},
{ 8, 12, 13, 4},
{ 8, 12, 14, 7},
{ 8, 12, 15, 6},
{ 8, 12, 16, 22},
{ 8, 12, 17, 23},
{ 8, 12, 18, 20},
{ 8, 12, 19, 21},
{ 8, 12, 20, 18},
{ 8, 12, 21, 19},
{ 8, 12, 22, 16},
{ 8, 12, 23, 17},
{ 8, 16, 0, 19},
{ 8, 16, 1, 18},
{ 8, 16, 2, 17},
{ 8, 16, 3, 16},
{ 8, 16, 4, 22},
{ 8, 16, 5, 23},
{ 8, 16, 6, 20},
{ 8, 16, 7, 21},
{ 8, 16, 8, 7},
{ 8, 16, 9, 6},
{ 8, 16, 10, 5},
{ 8, 16, 11, 4},
{ 8, 16, 12, 2},
{ 8, 16, 13, 3},
{ 8, 16, 14, 0},
{ 8, 16, 15, 1},
{ 8, 16, 16, 13},
{ 8, 16, 17, 12},
{ 8, 16, 18, 15},
{ 8, 16, 19, 14},
{ 8, 16, 20, 9},
{ 8, 16, 21, 8},
{ 8, 16, 22, 11},
{ 8, 16, 23, 10},
{ 9, 18, 0, 6},
{ 9, 18, 1, 7},
{ 9, 18, 2, 4},
{ 9, 18, 3, 5},
{ 9, 18, 4, 2},
{ 9, 18, 5, 3},
{ 9, 18, 6, 0},
{ 9, 18, 7, 1},
{ 9, 18, 8, 17},
{ 9, 18, 9, 16},
{ 9, 18, 10, 19},
{ 9, 18, 11, 18},
{ 9, 18, 12, 20},
{ 9, 18, 13, 21},
{ 9, 18, 14, 22},
{ 9, 18, 15, 23},
{ 9, 18, 16, 9},
{ 9, 18, 17, 8},
{ 9, 18, 18, 11},
{ 9, 18, 19, 10},
{ 9, 18, 20, 12},
{ 9, 18, 21, 13},
{ 9, 18, 22, 14},
{ 9, 18, 23, 15},
{ 10, 17, 0, 14},
{ 10, 17, 1, 15},
{ 10, 17, 2, 12},
{ 10, 17, 3, 13},
{ 10, 17, 4, 11},
{ 10, 17, 5, 10},
{ 10, 17, 6, 9},
{ 10, 17, 7, 8},
{ 10, 17, 8, 21},
{ 10, 17, 9, 20},
{ 10, 17, 10, 23},
{ 10, 17, 11, 22},
{ 10, 17, 12, 17},
{ 10, 17, 13, 16},
{ 10, 17, 14, 19},
{ 10, 17, 15, 18},
{ 10, 17, 16, 3},
{ 10, 17, 17, 2},
{ 10, 17, 18, 1},
{ 10, 17, 19, 0},
{ 10, 17, 20, 6},
{ 10, 17, 21, 7},
{ 10, 17, 22, 4},
{ 10, 17, 23, 5},
{ 10, 22, 0, 17},
{ 10, 22, 1, 16},
{ 10, 22, 2, 19},
{ 10, 22, 3, 18},
{ 10, 22, 4, 21},
{ 10, 22, 5, 20},
{ 10, 22, 6, 23},
{ 10, 22, 7, 22},
{ 10, 22, 8, 6},
{ 10, 22, 9, 7},
{ 10, 22, 10, 4},
{ 10, 22, 11, 5},
{ 10, 22, 12, 3},
{ 10, 22, 13, 2},
{ 10, 22, 14, 1},
{ 10, 22, 15, 0},
{ 10, 22, 16, 14},
{ 10, 22, 17, 15},
{ 10, 22, 18, 12},
{ 10, 22, 19, 13},
{ 10, 22, 20, 11},
{ 10, 22, 21, 10},
{ 10, 22, 22, 9},
{ 10, 22, 23, 8},
{ 10, 23, 0, 2},
{ 10, 23, 1, 3},
{ 10, 23, 2, 0},
{ 10, 23, 3, 1},
{ 10, 23, 4, 7},
{ 10, 23, 5, 6},
{ 10, 23, 6, 5},
{ 10, 23, 7, 4},
{ 10, 23, 8, 9},
{ 10, 23, 9, 8},
{ 10, 23, 10, 11},
{ 10, 23, 11, 10},
{ 10, 23, 12, 13},
{ 10, 23, 13, 12},
{ 10, 23, 14, 15},
{ 10, 23, 15, 14},
{ 10, 23, 16, 19},
{ 10, 23, 17, 18},
{ 10, 23, 18, 17},
{ 10, 23, 19, 16},
{ 10, 23, 20, 22},
{ 10, 23, 21, 23},
{ 10, 23, 22, 20},
{ 10, 23, 23, 21},
{ 11, 12, 0, 18},
{ 11, 12, 1, 19},
{ 11, 12, 2, 16},
{ 11, 12, 3, 17},
{ 11, 12, 4, 23},
{ 11, 12, 5, 22},
{ 11, 12, 6, 21},
{ 11, 12, 7, 20},
{ 11, 12, 8, 5},
{ 11, 12, 9, 4},
{ 11, 12, 10, 7},
{ 11, 12, 11, 6},
{ 11, 12, 12, 1},
{ 11, 12, 13, 0},
{ 11, 12, 14, 3},
{ 11, 12, 15, 2},
{ 11, 12, 16, 15},
{ 11, 12, 17, 14},
{ 11, 12, 18, 13},
{ 11, 12, 19, 12},
{ 11, 12, 20, 10},
{ 11, 12, 21, 11},
{ 11, 12, 22, 8},
{ 11, 12, 23, 9},
{ 12, 15, 0, 6},
{ 12, 15, 1, 7},
{ 12, 15, 2, 4},
{ 12, 15, 3, 5},
{ 12, 15, 4, 2},
{ 12, 15, 5, 3},
{ 12, 15, 6, 0},
{ 12, 15, 7, 1},
{ 12, 15, 8, 17},
{ 12, 15, 9, 16},
{ 12, 15, 10, 19},
{ 12, 15, 11, 18},
{ 12, 15, 12, 20},
{ 12, 15, 13, 21},
{ 12, 15, 14, 22},
{ 12, 15, 15, 23},
{ 12, 15, 16, 9},
{ 12, 15, 17, 8},
{ 12, 15, 18, 11},
{ 12, 15, 19, 10},
{ 12, 15, 20, 12},
{ 12, 15, 21, 13},
{ 12, 15, 22, 14},
{ 12, 15, 23, 15},
{ 12, 28, 0, 22},
{ 12, 28, 1, 23},
{ 12, 28, 2, 20},
{ 12, 28, 3, 21},
{ 12, 28, 4, 18},
{ 12, 28, 5, 19},
{ 12, 28, 6, 16},
{ 12, 28, 7, 17},
{ 12, 28, 8, 13},
{ 12, 28, 9, 12},
{ 12, 28, 10, 15},
{ 12, 28, 11, 14},
{ 12, 28, 12, 8},
{ 12, 28, 13, 9},
{ 12, 28, 14, 10},
{ 12, 28, 15, 11},
{ 12, 28, 16, 5},
{ 12, 28, 17, 4},
{ 12, 28, 18, 7},
{ 12, 28, 19, 6},
{ 12, 28, 20, 0},
{ 12, 28, 21, 1},
{ 12, 28, 22, 2},
{ 12, 28, 23, 3},
{ 13, 17, 0, 1},
{ 13, 17, 1, 0},
{ 13, 17, 2, 3},
{ 13, 17, 3, 2},
{ 13, 17, 4, 5},
{ 13, 17, 5, 4},
{ 13, 17, 6, 7},
{ 13, 17, 7, 6},
{ 13, 17, 8, 10},
{ 13, 17, 9, 11},
{ 13, 17, 10, 8},
{ 13, 17, 11, 9},
{ 13, 17, 12, 15},
{ 13, 17, 13, 14},
{ 13, 17, 14, 13},
{ 13, 17, 15, 12},
{ 13, 17, 16, 18},
{ 13, 17, 17, 19},
{ 13, 17, 18, 16},
{ 13, 17, 19, 17},
{ 13, 17, 20, 23},
{ 13, 17, 21, 22},
{ 13, 17, 22, 21},
{ 13, 17, 23, 20},
{ 14, 28, 0, 4},
{ 14, 28, 1, 5},
{ 14, 28, 2, 6},
{ 14, 28, 3, 7},
{ 14, 28, 4, 1},
{ 14, 28, 5, 0},
{ 14, 28, 6, 3},
{ 14, 28, 7, 2},
{ 14, 28, 8, 16},
{ 14, 28, 9, 17},
{ 14, 28, 10, 18},
{ 14, 28, 11, 19},
{ 14, 28, 12, 21},
{ 14, 28, 13, 20},
{ 14, 28, 14, 23},
{ 14, 28, 15, 22},
{ 14, 28, 16, 10},
{ 14, 28, 17, 11},
{ 14, 28, 18, 8},
{ 14, 28, 19, 9},
{ 14, 28, 20, 14},
{ 14, 28, 21, 15},
{ 14, 28, 22, 12},
{ 14, 28, 23, 13},
{ 14, 29, 0, 18},
{ 14, 29, 1, 19},
{ 14, 29, 2, 16},
{ 14, 29, 3, 17},
{ 14, 29, 4, 23},
{ 14, 29, 5, 22},
{ 14, 29, 6, 21},
{ 14, 29, 7, 20},
{ 14, 29, 8, 5},
{ 14, 29, 9, 4},
{ 14, 29, 10, 7},
{ 14, 29, 11, 6},
{ 14, 29, 12, 1},
{ 14, 29, 13, 0},
{ 14, 29, 14, 3},
{ 14, 29, 15, 2},
{ 14, 29, 16, 15},
{ 14, 29, 17, 14},
{ 14, 29, 18, 13},
{ 14, 29, 19, 12},
{ 14, 29, 20, 10},
{ 14, 29, 21, 11},
{ 14, 29, 22, 8},
{ 14, 29, 23, 9},
{ 15, 16, 0, 1},
{ 15, 16, 1, 0},
{ 15, 16, 2, 3},
{ 15, 16, 3, 2},
{ 15, 16, 4, 5},
{ 15, 16, 5, 4},
{ 15, 16, 6, 7},
{ 15, 16, 7, 6},
{ 15, 16, 8, 10},
{ 15, 16, 9, 11},
{ 15, 16, 10, 8},
{ 15, 16, 11, 9},
{ 15, 16, 12, 15},
{ 15, 16, 13, 14},
{ 15, 16, 14, 13},
{ 15, 16, 15, 12},
{ 15, 16, 16, 18},
{ 15, 16, 17, 19},
{ 15, 16, 18, 16},
{ 15, 16, 19, 17},
{ 15, 16, 20, 23},
{ 15, 16, 21, 22},
{ 15, 16, 22, 21},
{ 15, 16, 23, 20},
{ 15, 25, 0, 7},
{ 15, 25, 1, 6},
{ 15, 25, 2, 5},
{ 15, 25, 3, 4},
{ 15, 25, 4, 3},
{ 15, 25, 5, 2},
{ 15, 25, 6, 1},
{ 15, 25, 7, 0},
{ 15, 25, 8, 19},
{ 15, 25, 9, 18},
{ 15, 25, 10, 17},
{ 15, 25, 11, 16},
{ 15, 25, 12, 23},
{ 15, 25, 13, 22},
{ 15, 25, 14, 21},
{ 15, 25, 15, 20},
{ 15, 25, 16, 11},
{ 15, 25, 17, 10},
{ 15, 25, 18, 9},
{ 15, 25, 19, 8},
{ 15, 25, 20, 15},
{ 15, 25, 21, 14},
{ 15, 25, 22, 13},
{ 15, 25, 23, 12},
{ 16, 20, 0, 8},
{ 16, 20, 1, 9},
{ 16, 20, 2, 10},
{ 16, 20, 3, 11},
{ 16, 20, 4, 13},
{ 16, 20, 5, 12},
{ 16, 20, 6, 15},
{ 16, 20, 7, 14},
{ 16, 20, 8, 0},
{ 16, 20, 9, 1},
{ 16, 20, 10, 2},
{ 16, 20, 11, 3},
{ 16, 20, 12, 5},
{ 16, 20, 13, 4},
{ 16, 20, 14, 7},
{ 16, 20, 15, 6},
{ 16, 20, 16, 22},
{ 16, 20, 17, 23},
{ 16, 20, 18, 20},
{ 16, 20, 19, 21},
{ 16, 20, 20, 18},
{ 16, 20, 21, 19},
{ 16, 20, 22, 16},
{ 16, 20, 23, 17},
{ 16, 23, 0, 12},
{ 16, 23, 1, 13},
{ 16, 23, 2, 14},
{ 16, 23, 3, 15},
{ 16, 23, 4, 8},
{ 16, 23, 5, 9},
{ 16, 23, 6, 10},
{ 16, 23, 7, 11},
{ 16, 23, 8, 20},
{ 16, 23, 9, 21},
{ 16, 23, 10, 22},
{ 16, 23, 11, 23},
{ 16, 23, 12, 16},
{ 16, 23, 13, 17},
{ 16, 23, 14, 18},
{ 16, 23, 15, 19},
{ 16, 23, 16, 0},
{ 16, 23, 17, 1},
{ 16, 23, 18, 2},
{ 16, 23, 19, 3},
{ 16, 23, 20, 4},
{ 16, 23, 21, 5},
{ 16, 23, 22, 6},
{ 16, 23, 23, 7},
{ 17, 27, 0, 13},
{ 17, 27, 1, 12},
{ 17, 27, 2, 15},
{ 17, 27, 3, 14},
{ 17, 27, 4, 9},
{ 17, 27, 5, 8},
{ 17, 27, 6, 11},
{ 17, 27, 7, 10},
{ 17, 27, 8, 22},
{ 17, 27, 9, 23},
{ 17, 27, 10, 20},
{ 17, 27, 11, 21},
{ 17, 27, 12, 19},
{ 17, 27, 13, 18},
{ 17, 27, 14, 17},
{ 17, 27, 15, 16},
{ 17, 27, 16, 2},
{ 17, 27, 17, 3},
{ 17, 27, 18, 0},
{ 17, 27, 19, 1},
{ 17, 27, 20, 7},
{ 17, 27, 21, 6},
{ 17, 27, 22, 5},
{ 17, 27, 23, 4},
{ 20, 26, 0, 8},
{ 20, 26, 1, 9},
{ 20, 26, 2, 10},
{ 20, 26, 3, 11},
{ 20, 26, 4, 13},
{ 20, 26, 5, 12},
{ 20, 26, 6, 15},
{ 20, 26, 7, 14},
{ 20, 26, 8, 0},
{ 20, 26, 9, 1},
{ 20, 26, 10, 2},
{ 20, 26, 11, 3},
{ 20, 26, 12, 5},
{ 20, 26, 13, 4},
{ 20, 26, 14, 7},
{ 20, 26, 15, 6},
{ 20, 26, 16, 22},
{ 20, 26, 17, 23},
{ 20, 26, 18, 20},
{ 20, 26, 19, 21},
{ 20, 26, 20, 18},
{ 20, 26, 21, 19},
{ 20, 26, 22, 16},
{ 20, 26, 23, 17},
{ 21, 26, 0, 17},
{ 21, 26, 1, 16},
{ 21, 26, 2, 19},
{ 21, 26, 3, 18},
{ 21, 26, 4, 21},
{ 21, 26, 5, 20},
{ 21, 26, 6, 23},
{ 21, 26, 7, 22},
{ 21, 26, 8, 6},
{ 21, 26, 9, 7},
{ 21, 26, 10, 4},
{ 21, 26, 11, 5},
{ 21, 26, 12, 3},
{ 21, 26, 13, 2},
{ 21, 26, 14, 1},
{ 21, 26, 15, 0},
{ 21, 26, 16, 14},
{ 21, 26, 17, 15},
{ 21, 26, 18, 12},
{ 21, 26, 19, 13},
{ 21, 26, 20, 11},
{ 21, 26, 21, 10},
{ 21, 26, 22, 9},
{ 21, 26, 23, 8},
{ 22, 24, 0, 1},
{ 22, 24, 1, 0},
{ 22, 24, 2, 3},
{ 22, 24, 3, 2},
{ 22, 24, 4, 5},
{ 22, 24, 5, 4},
{ 22, 24, 6, 7},
{ 22, 24, 7, 6},
{ 22, 24, 8, 10},
{ 22, 24, 9, 11},
{ 22, 24, 10, 8},
{ 22, 24, 11, 9},
{ 22, 24, 12, 15},
{ 22, 24, 13, 14},
{ 22, 24, 14, 13},
{ 22, 24, 15, 12},
{ 22, 24, 16, 18},
{ 22, 24, 17, 19},
{ 22, 24, 18, 16},
{ 22, 24, 19, 17},
{ 22, 24, 20, 23},
{ 22, 24, 21, 22},
{ 22, 24, 22, 21},
{ 22, 24, 23, 20},
{ 23, 25, 0, 9},
{ 23, 25, 1, 8},
{ 23, 25, 2, 11},
{ 23, 25, 3, 10},
{ 23, 25, 4, 12},
{ 23, 25, 5, 13},
{ 23, 25, 6, 14},
{ 23, 25, 7, 15},
{ 23, 25, 8, 2},
{ 23, 25, 9, 3},
{ 23, 25, 10, 0},
{ 23, 25, 11, 1},
{ 23, 25, 12, 6},
{ 23, 25, 13, 7},
{ 23, 25, 14, 4},
{ 23, 25, 15, 5},
{ 23, 25, 16, 20},
{ 23, 25, 17, 21},
{ 23, 25, 18, 22},
{ 23, 25, 19, 23},
{ 23, 25, 20, 17},
{ 23, 25, 21, 16},
{ 23, 25, 22, 19},
{ 23, 25, 23, 18},
{ 23, 27, 0, 19},
{ 23, 27, 1, 18},
{ 23, 27, 2, 17},
{ 23, 27, 3, 16},
{ 23, 27, 4, 22},
{ 23, 27, 5, 23},
{ 23, 27, 6, 20},
{ 23, 27, 7, 21},
{ 23, 27, 8, 7},
{ 23, 27, 9, 6},
{ 23, 27, 10, 5},
{ 23, 27, 11, 4},
{ 23, 27, 12, 2},
{ 23, 27, 13, 3},
{ 23, 27, 14, 0},
{ 23, 27, 15, 1},
{ 23, 27, 16, 13},
{ 23, 27, 17, 12},
{ 23, 27, 18, 15},
{ 23, 27, 19, 14},
{ 23, 27, 20, 9},
{ 23, 27, 21, 8},
{ 23, 27, 22, 11},
{ 23, 27, 23, 10}
};
int pairsPos = 1032;

/////////////////////////////////////////

//struct pairs_s pairs[100000];
//int pairsPos = 0;

struct allB_s {
	int x;
	int y;
	int z;
};

struct tmp_s {
	int b1;
	int p1;
	int o11;
	int b11;
	int pos1;
	int pos_1;

	int o22;
	int b22;
	int b2;
	int p2;
	int pos2;
	int pos_2;

	int mapx;
	int mapy;
	int mapz;
	int x1;
	int y1;
	int z1;

	int x_1;
	int y_1;
	int z_1;

	int x2;
	int y2;
	int z2;

	int x_2;
	int y_2;
	int z_2;
};
struct tmp_s tmpxyz[2000];
struct pa_s {
	int b1;
	int b2;
};
map<pair<int, int>, int> mp;
int paPos = 0;


#define MAXALLB 10000
struct allB_s allB[MAXALLB];

int allBPos = 0;
struct beacon_s beacon[100];
struct beacon_s beaconOrig[100];

void matmul(int ma[3][3], int threebyone[3], int beaconPos, int jpos, int pos);

//rotational
/*
int m1[3][3] = {{+1, 0, 0}, {0, 0, +1}, {0, -1, 0}};
int m2[3][3] = {{0, +1, 0}, {0, 0, +1}, {+1, 0, 0}};
int m3[3][3] = {{0, +1, 0}, {+1, 0, 0}, {0, 0, -1}};
*/
//xyz 
int m[48][3][3] =
{
{{1, 0, 0}, {0,1,0}, {0,0,1}},
{{1, 0, 0}, {0,1,0}, {0,0,-1}},
{{1, 0, 0}, {0,-1,0}, {0,0,1}},
{{1, 0, 0}, {0,-1,0}, {0,0,-1}},
{{-1, 0, 0}, {0,1,0}, {0,0,1}},
{{-1, 0, 0}, {0,1,0}, {0,0,-1}},
{{-1, 0, 0}, {0,-1,0}, {0,0,1}},
{{-1, 0, 0}, {0,-1,0}, {0,0,-1}},
//xzy
{{1, 0, 0}, {0,0,1}, {0,1,0}},
{{1, 0, 0}, {0,0,1}, {0,-1,0}},
{{1, 0, 0}, {0,0,-1}, {0,1,0}},
{{1, 0, 0}, {0,0,-1}, {0,-1,0}},
{{-1, 0, 0}, {0,0,1}, {0,1,0}},
{{-1, 0, 0}, {0,0,1}, {0,-1,0}},
{{-1, 0, 0}, {0,0,-1}, {0,1,0}},
{{-1, 0, 0}, {0,0,-1}, {0,-1,0}},
//yxz
{{0, 1, 0}, {1,0,0}, {0,0,1}},
{{0, 1, 0}, {1,0,0}, {0,0,-1}},
{{0, 1, 0}, {-1,0,0}, {0,0,1}},
{{0, 1, 0}, {-1,0,0}, {0,0,-1}},
{{0, -1, 0}, {1,0,0}, {0,0,1}},
{{0, -1, 0}, {1,0,0}, {0,0,-1}},
{{0, -1, 0}, {-1,0,0}, {0,0,1}},
{{0, -1, 0}, {-1,0,0}, {0,0,-1}},
//yzx
{{0, 1, 0}, {0,0,1}, {1,0,0}},
{{0, 1, 0}, {0,0,1}, {-1,0,0}},
{{0, 1, 0}, {0,0,-1}, {1,0,0}},
{{0, 1, 0}, {0,0,-1}, {-1,0,0}},
{{0, -1, 0}, {0,0,1}, {1,0,0}},
{{0, -1, 0}, {0,0,1}, {-1,0,0}},
{{0, -1, 0}, {0,0,-1}, {1,0,0}},
{{0, -1, 0}, {0,0,-1}, {-1,0,0}},
//zxy
{{0, 0, 1}, {1,0,0}, {0,1,0}},
{{0, 0, 1}, {1,0,0}, {0,-1,0}},
{{0, 0, 1}, {-1,0,0}, {0,1,0}},
{{0, 0, 1}, {-1,0,0}, {0,-1,0}},
{{0, 0, -1}, {1,0,0}, {0,1,0}},
{{0, 0, -1}, {1,0,0}, {0,-1,0}},
{{0, 0, -1}, {-1,0,0}, {0,1,0}},
{{0, 0, -1}, {-1,0,0}, {0,-1,0}},
//zyx
{{0, 0, 1}, {0,1,0}, {1,0,0}},
{{0, 0, 1}, {0,1,0}, {-1,0,0}},
{{0, 0, 1}, {0,-1,0}, {1,0,0}},
{{0, 0, 1}, {0,-1,0}, {-1,0,0}},
{{0, 0, -1}, {0,1,0}, {1,0,0}},
{{0, 0, -1}, {0,1,0}, {-1,0,0}},
{{0, 0, -1}, {0,-1,0}, {1,0,0}},
{{0, 0, -1}, {0,-1,0}, {-1,0,0}}
};
/*
//xyz 
int m[0][3][3] ={{1, 0, 0}, {0,1,0}, {0,0,1}};
int m[1][3][3] = {{1, 0, 0}, {0,1,0}, {0,0,-1}};
int m[2][3][3] = {{1, 0, 0}, {0,-1,0}, {0,0,1}};
int m[3][3][3] = {{1, 0, 0}, {0,-1,0}, {0,0,-1}};
int m[4][3][3] = {{-1, 0, 0}, {0,1,0}, {0,0,1}};
int m[5][3][3] = {{-1, 0, 0}, {0,1,0}, {0,0,-1}};
int m[6][3][3] = {{-1, 0, 0}, {0,-1,0}, {0,0,1}};
int m[7][3][3] = {{-1, 0, 0}, {0,-1,0}, {0,0,-1}};
//xzy
int m[8][3][3] = {{1, 0, 0}, {0,0,1}, {0,1,0}};
int m[9][3][3] = {{1, 0, 0}, {0,0,1}, {0,-1,0}};
int m[10][3][3] = {{1, 0, 0}, {0,0,-1}, {0,1,0}};
int m[11][3][3] = {{1, 0, 0}, {0,0,-1}, {0,-1,0}};
int m[12][3][3] = {{-1, 0, 0}, {0,0,1}, {0,1,0}};
int m[13][3][3] = {{-1, 0, 0}, {0,0,1}, {0,-1,0}};
int m[14][3][3] = {{-1, 0, 0}, {0,0,-1}, {0,1,0}};
int m[15][3][3] = {{-1, 0, 0}, {0,0,-1}, {0,-1,0}};
//yxz
int m[16][3][3] = {{0, 1, 0}, {1,0,0}, {0,0,1}};
int m[17][3][3] = {{0, 1, 0}, {1,0,0}, {0,0,-1}};
int m[18][3][3] = {{0, 1, 0}, {-1,0,0}, {0,0,1}};
int m[19][3][3] = {{0, 1, 0}, {-1,0,0}, {0,0,-1}};
int m[20][3][3] = {{-0, 1, 0}, {1,0,0}, {0,0,1}};
int m[21][3][3] = {{-0, 1, 0}, {1,0,0}, {0,0,-1}};
int m[22][3][3] = {{-0, 1, 0}, {-1,0,0}, {0,0,1}};
int m[23][3][3] = {{-0, 1, 0}, {-1,0,0}, {0,0,-1}};
//yzx
int m[24][3][3] = {{0, 1, 0}, {0,0,1}, {1,0,0}};
int m[25][3][3] = {{0, 1, 0}, {0,0,1}, {-1,0,0}};
int m[26][3][3] = {{0, 1, 0}, {0,0,-1}, {1,0,0}};
int m[27][3][3] = {{0, 1, 0}, {0,0,-1}, {-1,0,0}};
int m[28][3][3] = {{-0, 1, 0}, {0,0,1}, {1,0,0}};
int m[29][3][3] = {{-0, 1, 0}, {0,0,1}, {-1,0,0}};
int m[30][3][3] = {{-0, 1, 0}, {0,0,-1}, {1,0,0}};
int m[31][3][3] = {{-0, 1, 0}, {0,0,-1}, {-1,0,0}};
//zxy
int m[32][3][3] = {{0, 0, 1}, {1,0,0}, {0,1,0}};
int m[33][3][3] = {{0, 0, 1}, {1,0,0}, {0,-1,0}};
int m[34][3][3] = {{0, 0, 1}, {-1,0,0}, {0,1,0}};
int m[35][3][3] = {{0, 0, 1}, {-1,0,0}, {0,-1,0}};
int m[36][3][3] = {{0, 0, -1}, {1,0,0}, {0,1,0}};
int m[37][3][3] = {{0, 0, -1}, {1,0,0}, {0,-1,0}};
int m[38][3][3] = {{0, 0, -1}, {-1,0,0}, {0,1,0}};
int m[39][3][3] = {{0, 0, -1}, {-1,0,0}, {0,-1,0}};
//zyx
int m[40][3][3] = {{0, 0, 1}, {0,1,0}, {1,0,0}};
int m[41][3][3] = {{0, 0, 1}, {0,1,0}, {-1,0,0}};
int m[42][3][3] = {{0, 0, 1}, {0,-1,0}, {1,0,0}};
int m[43][3][3] = {{0, 0, 1}, {0,-1,0}, {-1,0,0}};
int m[44][3][3] = {{0, 0, -1}, {0,1,0}, {1,0,0}};
int m[45][3][3] = {{0, 0, -1}, {0,1,0}, {-1,0,0}};
int m[46][3][3] = {{0, 0, -1}, {0,-1,0}, {1,0,0}};
int m[47][3][3] = {{0, 0, -1}, {0,-1,0}, {-1,0,0}};
*/
//--- beacon 0 ---
int same(int o1, int o2) {
	int count = 0;
	for (int qq = 1;  qq < beacon[0].beaconPos; qq++) {
		if (beacon[0].distxx[o1][qq-1][qq]  == beacon[0].distxx[o2][qq-1][qq] &&
		beacon[0].distyy[o1][qq-1][qq] == beacon[0].distyy[o2][qq-1][qq] &&
		beacon[0].distzz[o1][qq-1][qq] == beacon[0].distzz[o2][qq-1][qq]) {
			count++;
		}
	}
	if (count >= 11) {printf("count is %d\n", count);}
	if (count >= 11) {return 1;} else {return 0;}

}	
int main(int argc, char **argv)
{
	int count5 = 0;
	for (int l = 0; l < 48; l++) {
		//              a             e          i           g          h
		int a1 = m[l][0][0] * (m[l][1][1] * m[l][2][2] - m[l][1][2] * m[l][2][1]);
		//             b              d         l          g             f
		int b1 = m[l][0][1] * (m[l][1][0] * m[l][2][2] - m[l][2][0] * m[l][1][2]);
		//           c              d           h                 e        g
		int c1 = m[l][0][2] * (m[l][1][0] * m[l][2][1] - m[l][1][1] * m[l][2][0]);
		int det = a1 - b1 + c1;
		if (det == 1) {count5++;}
	}
	assert(count5 == 24);
	printf("count5 is %d\n", count5);
	printf("%d", argc); printf("%s\n", argv[1]); fflush(stdout);

	FILE *a = fopen(argv[1], "r"); printf("2021 Day19\n"); fflush(stdout);
	char line1[LINE];

	int leny = 0;
	int beaconNum = 0;
	int beaconPos = 0;
	while (1) {
		fgets(line1, LINE-1, a);
		if (feof(a)) break;
		line1[strlen(line1)-1] = '\0';
		printf("LINE: %s\n", line1);

		int ret = 0;
		if (line1[0] == '\0') {
			continue;
		} else {
			ret = sscanf(line1, "--- scanner %d ---", &beaconNum);
			if (ret == 1) {
				if (beaconNum > 100) {perror("too big\n"); exit(0);}
				beaconPos = 0;
				continue;
			} else {
				char Sx1[10], Sy1[10], Sz1[10];
				//int x1, y1, z1;
				ret =  sscanf(line1, "%[^,],%[^,],%[^\0]", Sx1, Sy1, Sz1);
				if (ret == 3) {
					beacon[beaconNum].x[beaconPos][0] = atoi(Sx1);
					beacon[beaconNum].y[beaconPos][0] = atoi(Sy1);
					beacon[beaconNum].z[beaconPos][0] = atoi(Sz1);

					if (beaconPos == 0) {
						beacon[beaconPos].scannerx = 0;
						beacon[beaconPos].scannery = 0;
						beacon[beaconPos].scannerz = 0;
					}
					beaconPos++;
					beacon[beaconNum].beaconPos = beaconPos;
				} else {
					printf("%s\n", line1);
					perror("not 3 \n"); exit(0);
				}
			}
		}

		leny++;

	}
	fclose(a);

	beaconNum++;
	printf("beaconNum is %d\n", beaconNum); getchar();
	beacon[0].scannerx = 0;
	beacon[0].scannery = 0;
	beacon[0].scannerz = 0;

	beacon[0].mapx = 0;
	beacon[0].mapy = 0;
	beacon[0].mapz = 0;

	beacon[0].orient = 0;

	for (int i = 1; i < beaconNum; i++) {
		beacon[i].scannerx = -999;
		beacon[i].scannery = -999;
		beacon[i].scannerz = -999;
	}

/*
	for (int i = 0; i < beaconNum; i++) {
		for (int j = 0; j < beacon[i].beaconPos; j++) {
			printf("%d %d %d -- ", beacon[i].x[j][0], beacon[i].y[j][0], beacon[i].z[j][0]);
		}
		printf("\n");
	} getchar();
*/

	int threebyone[3];
	for (int i = 0; i < beaconNum; i++) {
		for (int j = 0; j < beacon[i].beaconPos; j++) {
			int opos = 0;
			threebyone[0] = beacon[i].x[j][0];
			threebyone[1] = beacon[i].y[j][0];
			threebyone[2] = beacon[i].z[j][0];
			for (int l = 0; l < 48; l++) {
				int a1 = m[l][0][0] * (m[l][1][1] * m[l][2][2] - m[l][1][2] * m[l][2][1]);
				int b1 = m[l][0][1] * (m[l][1][0] * m[l][2][2] - m[l][2][0] * m[l][1][2]);
				int c1 = m[l][0][2] * (m[l][1][0] * m[l][2][1] - m[l][1][1] * m[l][2][0]);
				int det = a1 - b1 + c1;
				if (det == 1) {
					matmul(m[l], threebyone, i, j, opos);
					opos++;
					assert(opos <= 24);
				}
			}
			assert(opos == 24);
			//printf("%d %d %d -- ", beacon[i].x[j][0], beacon[i].y[j][0], beacon[i].z[j][0]);
		}
/*
		for (int j = 0; j < beacon[i].beaconPos; j++) {
			for (int q = 0; q < 24; q++) {
				printf("XYZ -- %d %d %d\n", beacon[i].x[j][q], beacon[i].y[j][q], beacon[i].z[j][q]); 
				if (beacon[i].x[j][q] == 0 && beacon[i].y[j][q] == 0 && beacon[i].z[j][q] == 0) {
					printf("ERROR\n"); getchar();
				}
				printf("-----------\n");
			}
		}
*/
	}

	printf("filling Orig\n");
	for (int i = 0; i < beaconNum; i++) {
		for (int k = 0; k < 24; k++) {
			for (int j = 0; j < beacon[i].beaconPos; j++) {
				beaconOrig[i].x[j][k] = beacon[i].x[j][k];
				beaconOrig[i].y[j][k] = beacon[i].y[j][k];
				beaconOrig[i].z[j][k] = beacon[i].z[j][k];
			}
		}
	
	}
	printf("after filling Orig...\n");

	printf("calc distance...\n"); fflush(stdout);
	for (int i = 0; i < beaconNum; i++) {
		for (int k = 0; k < 24; k++) {
			for (int j = 0; j < beacon[i].beaconPos; j++) {
				for (int l = 0; l < beacon[i].beaconPos; l++) {
					if (j == l) {continue;}
					beacon[i].distxx[k][j][l] = (beacon[i].x[j][k] - beacon[i].x[l][k]);
					beacon[i].distyy[k][j][l] = (beacon[i].y[j][k] - beacon[i].y[l][k]);
					beacon[i].distzz[k][j][l] = (beacon[i].y[j][k] - beacon[i].y[l][k]);
				}
			}
		}
	}
	printf("after calc dist\n"); fflush(stdout);

/*
	printf("calc2 distance..beacon JUST 0.\n"); fflush(stdout);
	for (int i = 0; i < 1; i++) {
		for (int k = 0; k < 24; k++) {
			for (int j = 0; j < beacon[i].beaconPos; j++) {
				for (int l = 0; l < beacon[i].beaconPos; l++) {
					if (j == l) {continue;}
					beacon[i].distxx[k][j][l] = abs(beacon[i].x[j][k] - beacon[i].x[l][k]);
					beacon[i].distyy[k][j][l] = abs(beacon[i].y[j][k] - beacon[i].y[l][k]);
					beacon[i].distzz[k][j][l] = abs(beacon[i].y[j][k] - beacon[i].y[l][k]);
				}
			}
		}
	}
	printf("after calc dist\n"); fflush(stdout);
*/

/*
	printf("same:\n");
	int o1 = 0;
	{
		for (int o2 = 1; o2 < 24; o2++) {
			if (o1 == o2) {break;}
			if (same(o1, o2) == 1) {
				printf("%d == %d\n", o1, o2);
			} else {
				printf("not same o1 o2 %d %d\n", o1, o2);
			}
		}
	}
*/

	
/*
	printf("HERE COMP 2,0,0,2\n");
	int count = 0;
	int b1 = 2;
	int o1 = 0;
	int b2 = 0;
	int o2 = 2;
	for (int p1b1 = 0; p1b1 < beacon[b1].beaconPos; p1b1++) {
	count = 0;
	for (int p2b1 = 0; p2b1 < beacon[b1].beaconPos; p2b1++) {
		if (p1b1 == p2b1) {continue;}
		alPos = 0;
		for (int p1b2 = 0; p1b2 < beacon[b2].beaconPos; p1b2++) {
			for (int p2b2 = 0; p2b2 < beacon[b2].beaconPos; p2b2++) {
				if (p1b2 == p2b2) {continue;}
				int found4 = 0;
				for (int q = 0; q < alPos; q++) {
					if ((al[q].p1b2 == p1b2 && al[q].p2b2 == al[q].p2b2) || (al[q].p1b2 == p2b2  && al[q].p2b2 == p1b2)) {
						found4 = 1;
						break;
					}
				}
				if (found4 = 0) {
					al[alPos].p1b2 = p1b2;
					al[alPos].p2b2 = p2b2;
					alPos++;
				}

				if (beacon[b1].distxx[o1][p1b1][p2b1]  == beacon[b2].distxx[o2][p1b2][p2b2] &&
					beacon[b1].distyy[o1][p1b1][p2b1] == beacon[b2].distyy[o2][p1b2][p2b2] &&
					beacon[b1].distzz[o1][p1b1][p2b1] == beacon[b2].distzz[o2][p1b2][p2b2]) {
					count++;
				}
			}
		}
	}
	printf("count is %d\n", count);
	
	}
	printf("------\n");
	count = 0;
	b1 = 0;
	b2 = 2;
	o1 = 2;
	o2 = 0;
	for (int p1b1 = 0; p1b1 < beacon[b1].beaconPos-1; p1b1++) {
	count = 0;
	for (int p2b1 = p1b1+1; p2b1 < beacon[b1].beaconPos; p2b1++) {
		for (int p1b2 = 0; p1b2 < beacon[b2].beaconPos-1; p1b2++) {
			for (int p2b2 = p1b2+1; p2b2 < beacon[b2].beaconPos; p2b2++) {

				if (beacon[b1].distxx[o1][p1b1][p2b1]  == beacon[b2].distxx[o2][p1b2][p2b2] &&
					beacon[b1].distyy[o1][p1b1][p2b1] == beacon[b2].distyy[o2][p1b2][p2b2] &&
					beacon[b1].distzz[o1][p1b1][p2b1] == beacon[b2].distzz[o2][p1b2][p2b2]) {
					count++;
				}
			}
		}
	}
	printf("count is %d\n", count);
	}
	printf("------\n"); getchar();
	//< 2 ,0,0,2},

*/
//pairZ(); exit(0);
	printf("starting GEN\n"); fflush(stdout);
/*
// GEN OF pairs
	//int b1_1[] = {0, 1, 1, 4};
	//int b2_2[] = {1, 3, 4, 2};
	{
		//for (int b1_1Pos = 0; b1_1Pos < beaconNum-1; b1_1Pos++) 
		//int b1 = b1_1[b1_1Pos];
		//int b2 = b2_2[b1_1Pos];

		for (int b1= 0; b1< beaconNum-1; b1++)
		{
			for (int b2 = b1+1; b2 < beaconNum; b2++)
			{
				if (b1 == b2) {continue;}

				//int found3 = 0;

				//for (int q1 = 0; q1 < pairsPos; q1++) { 
				//	if ((pairs[q1].b1 == b1 && pairs[q1].b2 == b2) || (pairs[q1].b2 == b1 && pairs[q1].b1 == b2)) {
				//		found3 = 1; break;
				//	}
				//}
				//if (found3 == 1) {continue;}
				//printf("***beacon [%d] v [%d] or:[%s]\n", b1, b2, var_orient); getchar();

				for (int o1 = 0; o1 < 24; o1++) 
				{
					//printf("using orient o1:%d for b1:%d\n", o1, b1); getchar();
					//int o2 = 0;
					for (int o2 = 0; o2 < 24; o2++) {
						for (int p1b1 = 0; p1b1 < beacon[b1].beaconPos; p1b1++) {
							int most[100] = {0};

							int count = 0;
							for (int p2b1 = 0; p2b1 < beacon[b1].beaconPos; p2b1++) {
								if (p1b1 == p2b1) {continue;}
								for (int p1b2 = 0; p1b2 < beacon[b2].beaconPos-1; p1b2++) {
									for (int p2b2 = p1b2+1; p2b2 < beacon[b2].beaconPos; p2b2++) {
										alPos = 0;
						                                if (p1b2 == p2b2) {continue;}
       							                        int found4 = 0;
										for (int q = 0; q < alPos; q++) {
											if (((al[q].p1b2 == p1b2) && (al[q].p2b2 == p2b2)) || ((al[q].p1b2 == p2b2) && (al[q].p2b2 == p1b2))) {
												found4 = 1;
												break;
											}
										}
										if (found4 == 0) {
											al[alPos].p1b2 = p1b2;
											al[alPos].p2b2 = p2b2;
											alPos++;
										} else {
											continue;
										}

										if (beacon[b1].distxx[o1][p1b1][p2b1]  == beacon[b2].distxx[o2][p1b2][p2b2] &&
												beacon[b1].distyy[o1][p1b1][p2b1] == beacon[b2].distyy[o2][p1b2][p2b2] &&
												beacon[b1].distzz[o1][p1b1][p2b1] == beacon[b2].distzz[o2][p1b2][p2b2]) {
											
											tmpxyz[count].b1 = b1;
											tmpxyz[count].pos1 = p1b1;
											tmpxyz[count].pos_1 = p2b1;
											tmpxyz[count].o11 = o1;

											tmpxyz[count].b2 = b2;
											tmpxyz[count].pos2 = p1b2;
											tmpxyz[count].pos_2 = p2b2;
											tmpxyz[count].o22 = o2;

											count++;
											most[p1b2]++;
											most[p2b2]++;

											//printf("count %d\n", count); fflush(stdout);
											if (count == 11) {
												if (b1 == 2 && b2 == 0) {
													//printf("2, 0 -- count %d\n", count); getchar();
												} else if (b1 == 0 && b2 == 2) {
													//printf("0, 2 -- count %d\n", count); getchar();
												}

												int max = 0;
												int maxI = -1;
												for (int i = 0; i < 30; i++) {
													if (most[i] > max) {max = most[i]; maxI = i;}
												}


												//printf("C O UNT11: maps: %d %d %d V %d %d %d", beacon[b1].scannerx, beacon[b1].scannery, beacon[b1].scannerz,
												//		beacon[b2].scannerx, beacon[b2].scannery, beacon[b2].scannerz); fflush(stdout);
												//printf("allBPos n ow %d\n", allBPos); fflush(stdout);
												for (int r = 0; r < 11; r++) {
													tmpxyz[r].b11 = b1;
													tmpxyz[r].o11 = o1;
													tmpxyz[r].b22 = b2;
													tmpxyz[r].o22 = o2;
													tmpxyz[r].p1 = tmpxyz[r].pos_1;
													tmpxyz[r].p2 = tmpxyz[r].pos_2 == maxI ? tmpxyz[r].pos2 : tmpxyz[r].pos_2;
													if ((b1 == 2 && b2 == 0) || (b1 == 0 && b2 == 2)) {
														//printf("%d %d (of b2...\n", tmpxyz[r].pos2, tmpxyz[r].pos_2);
													}
												}
												if (b1 == 2 && b2 == 0) {
													//printf("side b1:%d == b2:%d\n", p1b1, maxI);
												} else if (b1 == 0 && b2 == 2) {
													//printf("side b1:%d == b2:%d\n", p1b1, maxI);
												}
												for (int r = 0; r < 11; r++) {
													if ((b1 == 2 && b2 == 0) || (b1 == 0 && b2 == 2)) {
														//printf("r:%d p1,p2 == %d,%d \n", r, tmpxyz[r].p1, tmpxyz[r].p2);
													}
													tmpxyz[r].mapx = beacon[b1].x[tmpxyz[r].p1][o1] - beacon[b2].x[tmpxyz[r].p2][o2];
													tmpxyz[r].mapy = beacon[b1].y[tmpxyz[r].p1][o1] - beacon[b2].y[tmpxyz[r].p2][o2];
													tmpxyz[r].mapz = beacon[b1].z[tmpxyz[r].p1][o1] - beacon[b2].z[tmpxyz[r].p2][o2];
												}

												int found2 = 0;
												for (int r = 0; r < 11-1; r++) {//are all the 11 distances at this orient the same
													if (tmpxyz[r].mapx == tmpxyz[r+1].mapx && tmpxyz[r].mapy == tmpxyz[r+1].mapy &&
															tmpxyz[r].mapz == tmpxyz[r+1].mapz) {
													} else {
														found2 = 1;
														break;
													}
												}
												int xmain = beacon[b1].x[p1b1][o1] - beacon[b2].x[maxI][o2]; 
												int ymain = beacon[b1].y[p1b1][o1] - beacon[b2].y[maxI][o2];
												int zmain = beacon[b1].z[p1b1][o1] - beacon[b2].z[maxI][o2];
												if (found2 == 0) {
													if (b1 == 2 && b2 == 0) {
														//printf("2,0 maps same wo\n"); getchar();
													} else if (b1 == 0 && b2 == 2) {
														//printf("0,2 maps same wo\n"); getchar();
													}
													if (xmain == tmpxyz[0].mapx && ymain == tmpxyz[0].mapy && zmain == tmpxyz[0].mapz) {
														found2 = 0;
													} else {
														found2 = 1;
													}
													found2 = 0;
												}
												if (found2 == 0) {
												if (b1 == 2 && b2 == 0) {
													//printf("2,0 maps same wi\n"); getchar();
												} else if (b1 == 0 && b2 == 2) {
													//printf("0,2 maps same wi\n"); getchar();
												}
													//printf("MAPS SAME: b:%d V %d -- o: %d V %d\n", b1, b2, o1, o2);
													if (b1 == 0 && b2 == 1) {getchar();}
													count = 0;
													pairs[pairsPos].b1 = b1;	
													pairs[pairsPos].b2 = b2;	
													pairs[pairsPos].o1 = o1;	
													pairs[pairsPos].o2 = o2;	
													pairsPos++;
													if (b1 < b2) {
														mp[{b1,b2}] = 1;
													} else {
														mp[{b2,b1}] = 1;
													}
													goto changeORb2;
												} else {
													//printf("MAPS NOT SAME b:%dV%d o:%dV%d\n", b1, b2, o1, o2);
												}

											}
										}
									}
								}
							}
						}
changeORb2:
						continue;
					}
				}

			}
		}
	}
	printf("pairsPos: %d\n", pairsPos);

	printf("PPPPPPQQQQQQQ NB NB should be > 43 %d\n", (int)mp.size());
	for (auto it = mp.begin(); it != mp.end(); it++) {
		pair one = it->first;
		printf("%d %d\n", one.first, one.second);

	} printf("end just pairs gc\n");getchar(); 

	FILE *fd1 = fopen("file.pairs5", "w+");
	for (int i = 0; i < pairsPos; i++) {
		//printf("{ %d, %d, %d, %d},\n", pairs[i].b1, pairs[i].b2, pairs[i].o1, pairs[i].o2);
		fprintf(fd1, "{ %d, %d, %d, %d},\n", pairs[i].b1, pairs[i].b2, pairs[i].o1, pairs[i].o2);
	} printf("end pairs print %d pairsPos\n", pairsPos); getchar();
	fclose(fd1);
	printf("END PPPPPPPPPPPPPP\n");
	exit(0);
*/

/*
	printf("1919191919VVVVVVVVVVVVVVVVVVVV\n");
	for (int i = 0; i < pairsPos; i++) {
		if (pairs[i].b1 == 19 || pairs[i].b2 == 19) {
			printf("{ %d, %d, %d, %d},\n", pairs[i].b1, pairs[i].b2, pairs[i].o1, pairs[i].o2);
		}
	} 
	printf("1^^^^^^^^^^^^^^^^919191919\n"); getchar();

	printf("040404040VVVVVVVVVVVVVVVVVVVV\n");
	for (int i = 0; i < pairsPos; i++) {
		if ((pairs[i].b1 == 0 && pairs[i].b2 == 4) || (pairs[i].b2 == 0 && pairs[i].b1 == 4)) {
			printf("{ %d, %d, %d, %d},\n", pairs[i].b1, pairs[i].b2, pairs[i].o1, pairs[i].o2);
		}
	} 
	printf("0400404^^^^^^^^^^^919191919\n"); getchar();

	for (int i = 0; i < pairsPos; i++) {
		if (pairs[i].b1 < pairs[i].b2) {
			mp[{pairs[i].b1, pairs[i].b2}] = 1;
		} else {
			mp[{pairs[i].b2, pairs[i].b1}] = 1;
		}
	}
	printf("Pares...\n");
	for (auto it = mp.begin(); it != mp.end(); it++) {
		pair one = it->first;
		printf("%d %d\n", one.first, one.second);
	} printf("end just pairs gc\n");getchar(); 
	printf("xiz is %d\n", (int)mp.size());
*/

//int a1 = {0, 0, 0, 0, 0, 1, 1, 2, 3, 4, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 9, 10, 10, 10
/*
0 2
0 3
0 4
0 18
0 27
1 2
1 4
2 9
3 8
4 6
4 8
4 19
4 23
5 15
5 28
6 12
6 25
7 10
7 13
7 16
7 26
8 12
8 16
9 18
10 17
10 22
10 23
11 12
12 15
12 28
13 17
14 28
14 29
15 16
15 25
16 20
16 23
17 27
20 26
21 26
22 24
23 25
23 27
*/
	
	//for (int i = 0; i < beaconNum; i++) { printf("scanner: %d => %d %d %d\n", i, beacon[i].scannerx, beacon[i].scannery, beacon[i].scannerz);	}
	//int b1_1[] = {0, 1, 1, 4};
	//int b2_2[] = {1, 3, 4, 2};
	//             k l m n
	//int b1_11[] = {0,1,1,4}; //o1
	//int b2_22[] = {1,3,4,2}; //o2
//,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, 43
// 0 -> 43 LENGTH 44
                      //A  B   C   D   E  F   G   H   I  J  K   L   M   N   O   P   Q   R    S  T  U V   W   X   Y  Z    b   c   d  e   f   g  h   i  j   k   l    m   n  o   p   q   r  s
	//int b1_11[] = {0,  0,  0,  0,  0, 2,  18, 3,  8, 8, 12, 12, 16, 16, 20, 23, 23, 15, -1, 2, 1, 4, 4,  4,  4, 15,  5, 12,  6, 25, 16, 7, 7, 10, 10, 10, 17, 17, 12, 26, 22, 28, 7, 14};
	//int b2_22[] = {2,  3,  4, 18, 27, 9,   9, 8, 12,16, 15, 28, 20, 23, 26 ,25, 27, 16, -1, 1, 4, 6, 8, 19, 23,  5, 28,  6, 25, 15,  7,10,26, 17, 22, 23, 27, 13, 11, 21, 24, 14, 13, 29};
/*
< 7 13
32d30
< 14 28
*/
/*
PQQQQQ43
0 2
0 3
0 4
0 18
0 27
1 2
1 4
2 9
3 8
4 6
4 8
4 19
4 23
5 15
5 28
6 12
6 25
7 10
7 13
7 16
7 26
8 12
8 16
9 18
10 17
10 22
10 23
11 12
12 15
12 28
13 17
14 28
14 29
15 16
15 25
16 20
16 23
17 27
20 26
21 26
22 24
23 25
23 27
*/
//PPPPPPPPPPPPPP 41
/*
0 2 *
0 3 *
0 4 *
0 18 *
0 27 *
1 2 *
1 4 *
2 9 *
3 8 *
4 6 *
4 8 *
4 19 *
4 23 *
5 15 *
5 28 *
6 12 *
6 25 *
7 10 *
7 16 *
7 26 *
8 12 *
8 16 *
9 18 *
10 17 *
10 22 *
10 23 *
11 12 *
12 15 *
12 28 *
13 17 *
14 29 *
15 16 *
15 25 *
16 20 * *
16 23 *
17 27 *
20 26 *
21 26 *
22 24 *
23 25 *
23 27 *
END PPPPPPPPPPPPPP
*/

	printf("pairsPos is %d\n", pairsPos);
	struct res_s {
		int one;
		int two;
		int three;
		int four;
		int five;
	};
/*
	//struct res_s results[200]; int resultsPos = 0;
	lineIPos = 0;
	for (int k = 0; k < pairsPos; k++) {
		if (pairs[k].b1 == b1_11[0] && pairs[k].b2 == b2_22[0])  { // k= 0  1
			for (int l = 0; l < pairsPos; l++) {
				if (pairs[l].b1 == b1_11[1] && pairs[l].b2 == b2_22[1])  { // l 1 =  3
					for (int m = 0; m < pairsPos; m++) {
						if (pairs[m].b1 == b1_11[2] && pairs[m].b2 == b2_22[2])  { // m 1 =  4
							for (int n = 0; n < pairsPos; n++) { 
								if (pairs[n].b1 == b1_11[3] && pairs[n].b2 == b2_22[3])  { // n 4 2
									if (pairs[k].o2 == pairs[l].o1 && pairs[k].o2 == pairs[l].o1 && pairs[l].o1 == pairs[m].o1 && pairs[m].o2 == pairs[n].o1  ) {
										printf("%d %d %d %d %d\n", pairs[k].o1, pairs[l].o1, pairs[n].o2, pairs[l].o2, pairs[n].o1);
										lineI[lineIPos][0] = pairs[k].o1;
										lineI[lineIPos][1] = pairs[l].o1;
										lineI[lineIPos][2] = pairs[n].o2;
										lineI[lineIPos][3] = pairs[l].o2;
										lineI[lineIPos][4] = pairs[n].o1;
										lineIPos++;
									}
								}
							}
						}
					}
				}
			}
		}
	}
*/
//RRRRRRRRRRRRRRRRRRRRRRRRRR
	//               A   B   C   D   E  F  G   H  I  J  K   L    M  N   O  *Q  R   S  T   U   V   W   X   Y    Z   b   c   d  *P   e  k*   g  *f *h    i  j   *l    m   n   o   p  q   r   s
          //int b1_11[] = {0,  -1, -1,  -1, -1,  2,  9, 3,  8, 8, 16, 12, 16, 4, 20, 27, 12, -1, 2, 4,  4, -1,  4,  16, 15,  5, 12, -1, 23, 25, -1,  -1, 23,-1,  -1, 10, 27, 17, 12, 26, 22, 28, 14, 13};
	  //int b2_22[] = {2,  -1,  -1, -1, -1,  9, 18, 8, 12,16, 15, 28, 20, 23,26, 23, 15, -1, 1, 1,  6, -1, 19,  23,  5, 28,  6, -1, 25, 15, -1,  -1, 10,-1 , -1, 22, 17, 13, 11, 21, 24, 14, 29, 7};
//int b111[] = {0, 2,  9, 2, 1,  4, 4, 4, 8,  8, /**/ 4,  6, 23, 25, 12, 15,  5, 23, 6, 10, 7, 26, 8, 10, 12, 15, 20, 16, 23, /**/ 20, 10, 27, 17, 12, 26, 22, 28, 14, 13};
//int b222[] = {2, 9, 18, 1, 4, 19, 6, 8, 3, 16, /**/23, 12, 25, 15, 15,  5, 28, 10, 25, 7,16, 7, 12, 17, 28, 16, 16, 23, 27, /**/ 26, 22, 17, 13, 11, 21, 24, 14, 29, 7};



/*
4 23 *
5 15 *
5 28 *
6 12 *
6 25 **
7 10 **
7 16 **
7 26 **
8 12 **
10 17 **
10 23 *
12 15 *
12 28 **
15 16 **
15 25 *
16 20 **
16 23 **
23 25 *
23 27 **

*/
/*
				for (int qq = 1; qq < 30; qq++) {
					int qqb1Pos = -1; 
					for (int i = 0; i < 44; i++) {
						if (qq == b1_11[i]) {
							qqb1Pos = i;
							break;
						}
					}
						
					int qqb2Pos = -1; 
					for (int j = 0; j < 44; j++) {
						if (qq == b2_22[j]) {
							qqb2Pos = j;
							switch (qqb2Pos) {
								case 0: printf("A "); break;
								case 1: printf("B "); break;
								case 2: printf("C "); break;
								case 3: printf("D "); break;
								case 4: printf("E "); break;
								case 5: printf("F "); break;
								case 6: printf("G "); break;
								case 7: printf("H "); break;
								case 8: printf("I "); break;
								case 9: printf("J "); break;
								case 10: printf("K "); break;
								case 11: printf("L "); break;
								case 12: printf("M "); break;
								case 13: printf("N "); break;
								case 14: printf("O "); break;
								case 15: printf("Q "); break;
								case 16: printf("R "); break;
								case 17: printf("S "); break;
								case 18: printf("T "); break;
								case 19: printf("U "); break;
								case 20: printf("V "); break;
								case 21: printf("W "); break;
								case 22: printf("X "); break;
								case 23: printf("Y "); break;
								case 24: printf("Z "); break;
								case 25: printf("b "); break;
								case 26: printf("c "); break;
								case 27: printf("d "); break;
								case 28: printf("P "); break;
								case 29: printf("e "); break;
								case 30: printf("k "); break;
								case 31: printf("g "); break;
								case 32: printf("f "); break;
								case 33: printf("h "); break;
								case 34: printf("i "); break;
								case 35: printf("j "); break;
								case 36: printf("l "); break;
								case 37: printf("m "); break;
								case 38: printf("n "); break;
								case 39: printf("o "); break;
								case 40: printf("p "); break;
								case 41: printf("q "); break;
								case 42: printf("r "); break;
								case 43: printf("s "); break;
							}
							break;
						}
					}
					if (qqb1Pos != -1 && qqb2Pos != -1) {		
						assert(qqb1Pos > qqb2Pos);
					}
					
				}
				printf("\nclear...\n");
*/
	system("date");

//	FILE *out1 = fopen("lineI.snip", "w+");
//	lineIPos = 0;
////                A   B   C   D   E  F  G   H  I  J  K   L    M  N   O  *Q  R   S  T   U   V   W   X   Y    Z   b   c   d  *P   e  k*   g  *f *h    i  j   *l    m   n   o   p  q   r   s
// //int b1_11[] = {0,  -1, -1,  -1, -1,  2,  9, 3,  8, 8, 16, 12, 16, 4, 20, 27, 12, -1, 2, 4,  4, -1,  4,  16, 15,  5, 12, -1, 23, 25, -1,  -1, 23,-1,  -1, 10, 27, 17, 12, 26, 22, 28, 14, 13};
// //int b2_22[] = {2,  -1,  -1, -1, -1,  9, 18, 8, 12,16, 15, 28, 20, 23,26, 23, 15, -1, 1, 1,  6, -1, 19,  23,  5, 28,  6, -1, 25, 15, -1,  -1, 10,-1 , -1, 22, 17, 13, 11, 21, 24, 14, 29, 7};
////                 A  B  C  D  E  F   G  H   I   J  K  L  M  N        O   Q  R   S   T   U   V   W   X  Y  Z   b   c   d  P   e  k*   g  *f *h         i  j   *l  m   n   o   p  q   r   s
//int b1_11[] =     {0, 0, 0, 0, 0, 2,  9, 2, 1,  4, 4, 4, 3,  8,  4,  6, 23, -1, 25, 12, 15,  5, 23, 6, 10, 7, 26, 8, 10, 12, 15, 20, 16, 23,  20, 10, 27, 17, 12, 26, 22, 28, 14, 13};
//int b2_22[] =     {2, 3, 4,18,27, 9, 18, 1, 4, 19, 6, 8, 8, 16, 23, 12, 25, -1, 15, 15,  5, 28, 10, 25, 7,16, 7, 12, 17, 28, 16, 16, 23, 27,  26, 22, 17, 13, 11, 21, 24, 14, 29, 7};
//	{//4194304 CONCON
//		//long count4 = 0;
//		for (int A = 0; A < pairsPos; A++) {
//	
///*
//		for (int A = 0; A < pairsPos; A++) {
//					if (pairs[A].b1 == b1_11[0] && pairs[A].b2 == b2_22[0]) {
//			assert(pairs[A].b1 == 0);
//			assert(pairs[A].b2 == 2);
//		///printf("A ");
//*/
//		for (int B = 0; B < pairsPos; B++) { 
//					if (pairs[B].b1 == b1_11[1] && pairs[B].b2 == b2_22[1]) {
//			assert(pairs[B].b1 == 0);
//			assert(pairs[B].b2 == 3);
///*
//*/
//		for (int C = 0; C < pairsPos; C++) {
//					if (pairs[C].b1 == b1_11[2] && pairs[C].b2 == b2_22[2]) {
//			assert(pairs[C].b1 == 0);
//			assert(pairs[C].b2 == 4);
///*
//		for (int D = 0; D < pairsPos; D++) {
//					if (pairs[D].b1 == b1_11[3] && pairs[D].b2 == b2_22[3]) {
//			assert(pairs[D].b1 == 0);
//			assert(pairs[D].b2 == 18);
//*/
//		for (int E = 0; E < pairsPos; E++) {
//					if (pairs[E].b1 == b1_11[4] && pairs[E].b2 == b2_22[4]) {
//			assert(pairs[E].b1 == 0);
//			assert(pairs[E].b2 == 27);
//
///*
//*/
///*
//		for (int F = 0; F < pairsPos; F++) {
//					if (pairs[F].b1 == b1_11[5] && pairs[F].b2 == b2_22[5]) {
//			assert(pairs[A].b2 == 2);
//						if (pairs[A].o2 == pairs[F].o1) {
//			assert(pairs[F].b1 == 2);
//			assert(pairs[F].b2 == 9);
//		///printf("F ");
//*/
///*
//		for (int G = 0; G < pairsPos; G++) {
//					if (pairs[G].b1 == b1_11[6] && pairs[G].b2 == b2_22[6]) {
//			assert(pairs[F].b2 == 9);
//						if (pairs[F].o2 == pairs[G].o1) {
//			assert(pairs[G].b1 == 9);
//			assert(pairs[G].b2 == 18);
//		///printf("G ");
//*/
///*
//		for (int H = 0; H < pairsPos; H++) {
//					if (pairs[H].b1 == b1_11[7] && pairs[H].b2 == b2_22[7]) {
//			assert(pairs[A].b2 == 2);
//						if (pairs[A].o2 == pairs[H].o1) {
//			assert(pairs[H].b1 == 2);
//			assert(pairs[H].b2 == 1);
//		///printf("H ");
//*/
///*
//		for (int I = 0; I < pairsPos; I++) {
//					if (pairs[I].b1 == b1_11[8] && pairs[I].b2 == b2_22[8]) {
//			assert(pairs[H].b2 == 1);
//						if (pairs[H].o2 == pairs[I].o1) {
//			assert(pairs[I].b1 == 1);
//			assert(pairs[I].b2 == 4);
//		///printf("I ");
//*/
//		for (int J = 0; J < pairsPos; J++) {
//					if (pairs[J].b1 == b1_11[9] && pairs[J].b2 == b2_22[9]) {
//			assert(pairs[C].b2 == 4);
//						if (pairs[C].o2 == pairs[J].o1) { 
//			assert(pairs[J].b1 == 4);
//			assert(pairs[J].b2 == 19);
//		///printf("J ");
//		for (int K = 0; K < pairsPos; K++) {
//					if (pairs[K].b1 == b1_11[10] && pairs[K].b2 == b2_22[10]) {
//			assert(pairs[C].b2 == 4);
//						if (pairs[C].o2 == pairs[K].o1) {
//			assert(pairs[K].b1 == 4);
//			assert(pairs[K].b2 == 6);
//		///printf("K ");
///*
//*/
///*
//		for (int L = 0; L < pairsPos; L++) {
//					if (pairs[L].b1 == b1_11[11] && pairs[L].b2 == b2_22[11]) {
//			assert(pairs[C].b2 == 4);
//						if (pairs[C].o2 == pairs[L].o1) {
//			assert(pairs[L].b1 == 4);
//			assert(pairs[L].b2 == 8);
//		///printf("L ");
//*/
///*
//
//		for (int M = 0; M < pairsPos; M++) {
//					if (pairs[M].b1 == b1_11[12] && pairs[M].b2 == b2_22[12]) {
//			assert(pairs[B].b2 == 3);
//						if (pairs[B].o2 == pairs[M].o1) {
//			assert(pairs[M].b1 == 3);
//			assert(pairs[M].b2 == 8);
//*/
///*
//		///printf("M ");
//		for (int N = 0; N < pairsPos; N++) {
//					if (pairs[N].b1 == b1_11[13] && pairs[N].b2 == b2_22[13]) {
//			//assert(pairs[L].b2 == 8);
//						if (pairs[L].o2 == pairs[N].o1) {
//			//assert(pairs[N].b1 == 8);
//			//assert(pairs[N].b2 == 16);
//		///printf("N ");
//*/
//		for (int O = 0; O < pairsPos; O++) {
//					if (pairs[O].b1 == b1_11[14] && pairs[O].b2 == b2_22[14]) {
//			assert(pairs[C].b2 == 4);
//						if (pairs[C].o2 == pairs[O].o1) {
//			assert(pairs[O].b1 == 4);
//			assert(pairs[O].b2 == 23);
//		///printf("N ");
///*
//*/
///*
//		for (int Q = 0; Q < pairsPos; Q++) {
//					if (pairs[Q].b1 == b1_11[15] && pairs[Q].b2 == b2_22[15]) {
//			assert(pairs[K].b2 == 6);
//						if (pairs[K].o2 == pairs[Q].o1) {
//			assert(pairs[Q].b1 == 6);
//			assert(pairs[Q].b2 == 12);
//		//printf("NQ\n");
//*/
///*
//		for (int R = 0; R < pairsPos;R++) {
//					if (pairs[R].b1 == b1_11[16] && pairs[R].b2 == b2_22[16]) {
//			assert(pairs[O].b2 == 23);
//						if (pairs[R].o2 == pairs[R].o1) {
//			assert(pairs[R].b1 == 23);
//			assert(pairs[R].b2 == 25);
//*/
//
////                 A  B  C  D  E  F   G  H   I   J  K  L  M  N        O   Q  R   S   T   U   V    W   X  Y  Z   b   c   d  P   e  k*   g  *f *h         i  j   *l  m   n   o   p  q   r   s
//int b1_11[] =     {0, 0, 0, 0, 0, 2,  9, 2, 1,  4, 4, 4, 3,  8, /**/ 4,  6, 23, -1, 25, 12, 15,  5, 23, 6, 10, 7, 26, 8, 10, 12, 15, 20, 16, 23, /**/ 20, 10, 27, 17, 12, 26, 22, 28, 14, 13};
//int b2_22[] =     {2, 3, 4,18,27, 9, 18, 1, 4, 19, 6, 8, 8, 16, /**/23, 12, 25, -1, 15, 15,  5, 28, 10, 25, 7,16, 7, 12, 17, 28, 16, 16, 23, 27, /**/ 26, 22, 17, 13, 11, 21, 24, 14, 29, 7};
//				lineI[lineIPos][0] = pairs[A].o1; //line A
//					//lineI[lineIPos][0] = pairs[A].o1;
//				//lineI[lineIPos][1] = pairs[H].o2; //lineI & H
//					lineI[lineIPos][1] = pairs[A].o2;
//				//lineI[lineIPos][2] = pairs[A].o2; // line A F H
//					lineI[lineIPos][2] = pairs[A].o2;
//				lineI[lineIPos][3] = pairs[B].o2; //line B M
//					//lineI[lineIPos][3] = pairs[A].o2;
//				lineI[lineIPos][4] = pairs[C].o2;  //C & I J K etc
//					//lineI[lineIPos][4] = pairs[A].o2; 
//				//lineI[lineIPos][5] = pairs[A].o2; 
//					lineI[lineIPos][5] = pairs[A].o2; 
//				//lineI[lineIPos][6] = pairs[K].o2; 
//					lineI[lineIPos][6] = pairs[A].o2; 
//				//lineI[lineIPos][7] = pairs[A].o2; 
//					lineI[lineIPos][7] = pairs[A].o2; 
//				//lineI[lineIPos][8] = pairs[M].o2; 
//					lineI[lineIPos][8] = pairs[A].o2; 
//				//lineI[lineIPos][9] = pairs[F].o2;  //F G
//					lineI[lineIPos][9] = pairs[A].o2; 
//				//lineI[lineIPos][10] = pairs[X].o2; 
//					lineI[lineIPos][10] = pairs[A].o2; 
//				//lineI[lineIPos][11] = pairs[A].o2;
//					lineI[lineIPos][11] = pairs[A].o2;
//				//lineI[lineIPos][12] = pairs[Q].o2;
//					lineI[lineIPos][12] = pairs[A].o2;
//				//lineI[lineIPos][13] = pairs[A].o2;
//					lineI[lineIPos][13] = pairs[A].o2;
//				//lineI[lineIPos][14] = pairs[A].o2;
//					lineI[lineIPos][14] = pairs[A].o2;
//				//lineI[lineIPos][15] = pairs[A].o2;
//					lineI[lineIPos][15] = pairs[A].o2;
//				//lineI[lineIPos][16] = pairs[N].o2;
//					lineI[lineIPos][16] = pairs[A].o2;
//				//lineI[lineIPos][17] = pairs[A].o2;
//					lineI[lineIPos][17] = pairs[A].o2;
//				//lineI[lineIPos][18] = pairs[D].o2;  //D
//					lineI[lineIPos][18] = pairs[A].o2;
//				lineI[lineIPos][19] = pairs[J].o2;
//					//lineI[lineIPos][19] = pairs[A].o2;
//				//lineI[lineIPos][20] = pairs[A].o2;
//					lineI[lineIPos][20] = pairs[A].o2;
//				//lineI[lineIPos][21] = pairs[A].o2;
//					lineI[lineIPos][21] = pairs[A].o2;
//				//lineI[lineIPos][22] = pairs[A].o2;
//					lineI[lineIPos][22] = pairs[A].o2;
//				lineI[lineIPos][23] = pairs[O].o2;
//					//lineI[lineIPos][23] = pairs[A].o2;
//				//lineI[lineIPos][24] = pairs[A].o2;
//					lineI[lineIPos][24] = pairs[A].o2;
//				//lineI[lineIPos][25] = pairs[R].o2;
//					lineI[lineIPos][25] = pairs[A].o2;
//				//lineI[lineIPos][26] = pairs[A].o2;
//					lineI[lineIPos][26] = pairs[A].o2;
//				lineI[lineIPos][27] = pairs[E].o2;
//					//lineI[lineIPos][27] = pairs[A].o2;
//				//lineI[lineIPos][28] = pairs[A].o2;
//					lineI[lineIPos][28] = pairs[A].o2;
//				//lineI[lineIPos][29] = pairs[A].o2;
//					lineI[lineIPos][29] = pairs[A].o2;
//				//printf("%ld: ", lineIPos);
//				for (int i = 0; i < lineIPos; i++) {
//					int found = 0;
//					for (int j = 0; j < 30; j++) {
//						if (lineI[i][j] != lineI[lineIPos][j]) {
//							found = 1;
//							break;
//						}
//					}
//					if (found == 0) {
//						for (int i = 0; i < 30; i++) {
//							fprintf(out1, "%d ", lineI[lineIPos][i]);
//							//printf("%d ", lineI[lineIPos][i]);
//						}
//						fprintf(out1, "\n");
//						lineIPos++;
//						break;
//					}
//				}
//				//printf("\n");
///*
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//
//	}
//	}
//	}
//	}
//	}
//*/
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	}
//	//}
//}
//	fclose(out1);
//	system("date");
	//exit(0);
//	{//4194304
//		long count4 = 0;
//		for (int A = 0; A < pairsPos; A++) {
//					if (pairs[A].b1 == b1_11[0] && pairs[A].b2 == b2_22[0]) {
//					if (pairs[A].o1 == 0) {
//			assert(pairs[A].b1 == 0);
//			assert(pairs[A].b2 == 2);
///*
//		for (int B = 0; B < pairsPos; B++) 
//					if (pairs[B].b1 == b1_11[1] && pairs[B].b2 == b2_22[1]) 
//			assert(pairs[B].b1 == 0);
//			assert(pairs[B].b2 == 3);
//		for (int C = 0; C < pairsPos; C++) 
//					if (pairs[C].b1 == b1_11[2] && pairs[C].b2 == b2_22[2]) 
//			assert(pairs[C].b1 == 0);
//			assert(pairs[C].b2 == 4);
//		for (int D = 0; D < pairsPos; D++) 
//					if (pairs[D].b1 == b1_11[3] && pairs[D].b2 == b2_22[3]) 
//			assert(pairs[D].b1 == 0);
//			assert(pairs[D].b2 == 18);
//		for (int E = 0; E < pairsPos; E++) 
//					if (pairs[E].b1 == b1_11[4] && pairs[E].b2 == b2_22[4]) 
//			assert(pairs[E].b1 == 0);
//			assert(pairs[E].b2 == 27);
//*/
//		for (int F = 0; F < pairsPos; F++) {
//					if (pairs[F].b1 == b1_11[5] && pairs[F].b2 == b2_22[5]) {
//			assert(pairs[A].b2 == 2);
//						if (pairs[A].o2 == pairs[F].o1) {
//			assert(pairs[F].b1 == 2);
//			assert(pairs[F].b2 == 9);
//		for (int G = 0; G < pairsPos; G++) {
//					if (pairs[G].b1 == b1_11[6] && pairs[G].b2 == b2_22[6]) {
//			assert(pairs[F].b2 == 9);
//						if (pairs[F].o2 == pairs[G].o1) {
//			assert(pairs[G].b1 == 9);
//			assert(pairs[G].b2 == 18);
//		for (int H = 0; H < pairsPos; H++) {
//					if (pairs[H].b1 == b1_11[7] && pairs[H].b2 == b2_22[7]) {
//			assert(pairs[A].b2 == 2);
//						if (pairs[A].o2 == pairs[H].o1) {
//			assert(pairs[H].b1 == 2);
//			assert(pairs[H].b2 == 1);
//		//printf("BH\n");
//		for (int I = 0; I < pairsPos; I++) {
//					if (pairs[I].b1 == b1_11[8] && pairs[I].b2 == b2_22[8]) {
//			assert(pairs[H].b2 == 1);
//						if (pairs[H].o2 == pairs[I].o1) {
//			assert(pairs[I].b1 == 1);
//			assert(pairs[I].b2 == 4);
//		//printf("HI\n");
//		for (int J = 0; J < pairsPos; J++) {
//					if (pairs[J].b1 == b1_11[9] && pairs[J].b2 == b2_22[9]) {
//			assert(pairs[I].b2 == 4);
//						if (pairs[I].o2 == pairs[J].o1) { 
//			assert(pairs[J].b1 == 4);
//			assert(pairs[J].b2 == 19);
//		//printf("HJ\n");
//		for (int K = 0; K < pairsPos; K++) {
//					if (pairs[K].b1 == b1_11[10] && pairs[K].b2 == b2_22[10]) {
//			assert(pairs[I].b2 == 4);
//						if (pairs[I].o2 == pairs[K].o1) {
//			assert(pairs[K].b1 == 4);
//			assert(pairs[K].b2 == 6);
//		//printf("IK\n");
//		for (int L = 0; L < pairsPos; L++) {
//					if (pairs[L].b1 == b1_11[11] && pairs[L].b2 == b2_22[11]) {
//			assert(pairs[I].b2 == 4);
//						if (pairs[I].o2 == pairs[L].o1) {
//			assert(pairs[L].b1 == 4);
//			assert(pairs[L].b2 == 8);
//		//printf("IL\n");
//		for (int M = 0; M < pairsPos; M++) {
//					if (pairs[M].b1 == b1_11[12] && pairs[M].b2 == b2_22[12]) {
//			assert(pairs[L].b2 == 8);
//						if (pairs[L].o2 == pairs[M].o1) {
//			assert(pairs[M].b1 == 8);
//			assert(pairs[M].b2 == 3);
//		//printf("JM\n");
//		for (int N = 0; N < pairsPos; N++) {
//					if (pairs[N].b1 == b1_11[13] && pairs[N].b2 == b2_22[13]) {
//			assert(pairs[L].b2 == 8);
//						if (pairs[L].o2 == pairs[N].o1) {
//			assert(pairs[N].b1 == 8);
//			assert(pairs[N].b2 == 16);
//		//printf("CN\n");
//		for (int O = 0; O < pairsPos; O++) {
//					if (pairs[O].b1 == b1_11[14] && pairs[O].b2 == b2_22[14]) {
//			//assert(pairs[M].b2 == 20);
//						if (1/*pairs[M].o2 == pairs[O].o1*/) {
//			//assert(pairs[O].b1 == 20); assert(pairs[O].b2 == 26);
//		//printf("MO\n");
//		for (int Q = 0; Q < pairsPos; Q++) {
//					if (1pairs[Q].b1 == b1_11[15] && pairs[Q].b2 == b2_22[15]) {
//			//assert(pairs[E].b2 == 27);
//						if (1/*pairs[E].o2 == pairs[Q].o1*/) {
//			//assert(pairs[Q].b1 == 27); assert(pairs[Q].b2 == 23);
//		//printf("NQ\n");
//		for (int R = 0; R < pairsPos; R++) {
//					if (pairs[R].b1 == b1_11[16] && pairs[R].b2 == b2_22[16]) {
//			//assert(pairs[I].b2 == 12);
//						if (1/*pairs[I].o2 == pairs[R].o1*/) { 
//			//assert(pairs[R].b1 == 12); assert(pairs[R].b2 == 15);
//		//printf("IR\n");
////S == 18 == -1
//		for (int T = 0; T < pairsPos; T++) {
//					if (pairs[T].b1 == b1_11[18] && pairs[T].b2 == b2_22[18]) {
//			//assert(pairs[A].b2 == 2);
//						if (1/*pairs[A].o2 == pairs[T].o1*/) {
//			//assert(pairs[T].b1 == 2); assert(pairs[T].b2 == 1);
//		//printf("AT\n"); 
//		for (int U = 0; U < pairsPos; U++) {
//					if (pairs[U].b1 == b1_11[19] && pairs[U].b2 == b2_22[19]) {
//			//assert(pairs[C].b2 == 4);
//						if (1/*pairs[C].o2 == pairs[U].o1*/) {
//			//assert(pairs[U].b1 == 4); assert(pairs[U].b2 == 1);
//		//printf("TU\n");
//		for (int V = 0; V < pairsPos; V++) {
//					if (pairs[V].b1 == b1_11[20] && pairs[V].b2 == b2_22[20]) {
//			//assert(pairs[C].b2 == 4);
//						if (1/*pairs[C].o2 == pairs[V].o1*/) {
//			//assert(pairs[V].b1 == 4); assert(pairs[V].b2 == 6);
//		//printf("CV\n");
///*
//		for (int W = 0; W < pairsPos; W++) if (pairs[W].b1 == b1_11[21] && pairs[W].b2 == b2_22[21]) 
//			assert(pairs[C].b2 == 4); if (pairs[C].o2 == pairs[W].o1) assert(pairs[W].b1 == 4); assert(pairs[W].b2 == 8);
//		printf("CW\n");
//*/
//		for (int X = 0; X < pairsPos; X++) {
//
//					if (pairs[X].b1 == b1_11[22] && pairs[X].b2 == b2_22[22]) {
//			//assert(pairs[C].b2 == 4);
//						if (1/*pairs[C].o2 == pairs[X].o1*/) {
//			//assert(pairs[X].b1 == 4); assert(pairs[X].b2 == 19);
//			
//		//printf("CX\n");
//		for (int Y = 0; Y < pairsPos; Y++) {
//					if (pairs[Y].b1 == b1_11[23] && pairs[Y].b2 == b2_22[23]) {
//			//assert(pairs[J].b2 == 16);
//						if (1/*pairs[J].o2 == pairs[Y].o1*/) { 
//			//assert(pairs[Y].b1 == 16); assert(pairs[Y].b2 == 23);
//		//printf("JY\n");
//		for (int Z = 0; Z < pairsPos; Z++) {
//					if (pairs[Z].b1 == b1_11[24] && pairs[Z].b2 == b2_22[24]) {
//			//assert(pairs[R].b2 == 15);
//						if (1/*pairs[R].o2 == pairs[Z].o1*/) { 
//			//assert(pairs[Z].b1 == 15); assert(pairs[Z].b2 == 5);
//		//printf("KZ\n"); 
//		for (int b = 0; b < pairsPos; b++) {
//					if (pairs[b].b1 == b1_11[25] && pairs[b].b2 == b2_22[25]) {
//			//assert(pairs[Z].b2 == 5);
//						if (1/*pairs[Z].o2 == pairs[b].o1*/) {
//			//assert(pairs[b].b1 == 5); assert(pairs[b].b2 == 28);
//		//printf("Zb\n");
//		for (int c = 0; c < pairsPos; c++) {
//					if (pairs[c].b1 == b1_11[26] && pairs[c].b2 == b2_22[26]) {
//			//assert(pairs[I].b2 == 12);
//						if (1/*pairs[I].o2 == pairs[c].o1*/) {
//			//assert(pairs[c].b1 == 12); assert(pairs[c].b2 == 6);
//		//printf("Ic\n");
///*
//		for (int d = 0; d < pairsPos; d++) 
//					if (pairs[d].b1 == b1_11[27] && pairs[d].b2 == b2_22[27]) 
//			//assert(pairs[c].b2 == 6);
//						if (1/*pairs[c].o2 == pairs[d].o1*/) 
//			//assert(pairs[d].b1 == 6); assert(pairs[d].b2 == 25);
//		printf("Vd\n");
//*/
//		for (int P = 0; P < pairsPos; P++) {
//					if (pairs[P].b1 == b1_11[28] && pairs[P].b2 == b2_22[28]) {
//			//assert(pairs[N].b2 == 23);
//						if (1/*pairs[N].o2 == pairs[P].o1*/) { 
//			//assert(pairs[P].b1 == 23); assert(pairs[P].b2 == 25);
//		//printf("NP\n");
//		for (int e = 0; e < pairsPos; e++) {
//					if (pairs[e].b1 == b1_11[29] && pairs[e].b2 == b2_22[29]) {
//			//ssert(pairs[P].b2 == 25);
//						if (1/*pairs[P].o2 == pairs[e].o1*/) {
//			//assert(pairs[e].b1 == 25); assert(pairs[e].b2 == 15);
//		//printf("Pe\n");
///*
//		for (int k = 0; k < pairsPos; k++) if (pairs[k].b1 == b1_11[30] && pairs[k].b2 == b2_22[30]) 
//			assert(pairs[J].b2 == 16); if (pairs[J].o2 == pairs[k].o1) assert(pairs[k].b1 == 16); assert(pairs[k].b2 == 7);
//		printf("Jk\n");
//*/
///*
//		for (int g = 0; g < pairsPos; g++) if (pairs[g].b1 == b1_11[31] && pairs[g].b2 == b2_22[31]) 
//			assert(pairs[k].b2 == 7); if (pairs[k].o2 == pairs[g].o1) 
//			assert(pairs[g].b1 == 7); assert(pairs[g].b2 == 10);
//		//printf("fg\n");
//*/
//		for (int f = 0; f < pairsPos; f++) {
//					if (pairs[f].b1 == b1_11[32] && pairs[f].b2 == b2_22[32]) {
//			assert(pairs[Y].b2 == 23);
//						if (pairs[Y].o2 == pairs[f].o1)  {
//			//assert(pairs[f].b1 == 23); assert(pairs[f].b2 == 10);
//		//printf("gf\n");
///*
//		for (int h = 0; h < pairsPos; h++) if (pairs[h].b1 == b1_11[33] && pairs[h].b2 == b2_22[33]) 
//			assert(pairs[O].b2 == 26); assert(pairs[h].b1 == 26); assert(pairs[h].b2 == 7);
//						if (pairs[O].o2 == pairs[h].o1) assert(pairs[h].b1 == 26); assert(pairs[h].b2 == 7); //printf("Oh\n");
//*/
//		for (int i = 0; i < pairsPos; i++) {
//			 if (pairs[i].b1 == b1_11[34] && pairs[i].b2 == b2_22[34]) {
//				if (1/*pairs[f].o2 == pairs[i].o1*/) {
//			//assert(pairs[j].b1 == 10); assert(pairs[j].b2 == 26);
//		//printf("gi\n"); 
//		for (int j = 0; j < pairsPos; j++) {
//					if (pairs[j].b1 == b1_11[35] && pairs[j].b2 == b2_22[35]) {
//			//assert(pairs[f].b2 == 10);
//						if (1/*pairs[f].o2 == pairs[j].o1*/) {
//			assert(pairs[j].b1 == 10);
//			assert(pairs[j].b2 == 22);
//		//printf("gj\n");
//		for (int l = 0; l < pairsPos; l++) {
//					if (pairs[l].b1 == b1_11[36] && pairs[l].b2 == b2_22[36]) {
//			//assert(pairs[E].b2 == 27);
//						if (1/*pairs[E].o2 == pairs[l].o1*/) {
//			assert(pairs[l].b1 == 27);
//			assert(pairs[l].b2 == 17);
//		//printf("il\n");
//		for (int m = 0; m < pairsPos; m++) {
//					if (pairs[m].b1 == b1_11[37] && pairs[m].b2 == b2_22[37]) {
//			assert(pairs[l].b2 == 17);
//						if (1/*pairs[l].o2 == pairs[m].o1*/) {
//			assert(pairs[m].b1 == 17);
//			assert(pairs[m].b2 == 13);
//		//printf("im\n");
//		for (int n = 0; n < pairsPos; n++) {
//					if (pairs[n].b1 == b1_11[38] && pairs[n].b2 == b2_22[38]) {
//			//assert(pairs[I].b2 == 12);
//						if (1/*pairs[I].o2 == pairs[n].o1*/) {
//			assert(pairs[n].b1 == 12);
//			assert(pairs[n].b2 == 11);
//
//		//printf("In\n");
//		for (int o = 0; o < pairsPos; o++) {
//					if (pairs[o].b1 == b1_11[39] && pairs[o].b2 == b2_22[39]) {
//			//assert(pairs[O].b2 == 26);
//						if (1/*pairs[O].o2 == pairs[o].o1*/) {
//			assert(pairs[o].b1 == 26);
//			assert(pairs[o].b2 == 21);
//		//printf("Oo\n");
//		for (int p = 0; p < pairsPos; p++) {
//					if (pairs[p].b1 == b1_11[40] && pairs[p].b2 == b2_22[40]) {
//			//assert(pairs[j].b2 == 22);
//						if (1/*pairs[j].o2 == pairs[p].o1*/) {
//			assert(pairs[p].b1 == 22);
//			assert(pairs[p].b2 == 24);
//		//printf("jp\n");
//		for (int q = 0; q < pairsPos; q++) {
//					if (pairs[q].b1 == b1_11[41] && pairs[q].b2 == b2_22[41]) {
//			//assert(pairs[b].b2 == 28);
//						if (1/*pairs[b].o2 == pairs[q].o1*/) {
//			assert(pairs[q].b1 == 28);
//			assert(pairs[q].b2 == 14);
//		//printf("bq\n");
//		for (int r = 0; r < pairsPos; r++) {
//					if (pairs[r].b1 == b1_11[42] && pairs[r].b2 == b2_22[42]) {
//			//assert(pairs[q].b2 == 14);
//						if (1/*pairs[q].o2 == pairs[r].o1*/) {
//			assert(pairs[r].b1 == 14);
//			assert(pairs[r].b2 == 29);
//		//printf("qr\n");
//		for (int s = 0; s < pairsPos; s++) {
//					if (pairs[s].b1 == b1_11[43] && pairs[s].b2 == b2_22[43]) {
//			//assert(pairs[m].b2 == 13);
//						if (1/*pairs[m].o2 == pairs[s].o1*/) {
//			assert(pairs[s].b1 == 13);
//			assert(pairs[s].b2 == 7);
//		//printf("fs\n");
//		//printf("in the middle\n");
////CONOR
//						
//				lineI[lineIPos][0] = pairs[A].o1;
//				lineI[lineIPos][1] = pairs[T].o2;
//				lineI[lineIPos][2] = pairs[A].o2;
//				lineI[lineIPos][3] = pairs[B].o2;
//				lineI[lineIPos][4] = pairs[C].o2; 
//				lineI[lineIPos][5] = pairs[Z].o2; 
//				lineI[lineIPos][6] = pairs[V].o2; 
//				lineI[lineIPos][7] = pairs[s].o2; 
//				lineI[lineIPos][8] = pairs[H].o2; 
//				lineI[lineIPos][9] = pairs[F].o2; 
//				lineI[lineIPos][10] = pairs[f].o2; 
//				lineI[lineIPos][11] = pairs[n].o2;
//				lineI[lineIPos][12] = pairs[I].o2;
//				lineI[lineIPos][13] = pairs[m].o2;
//				lineI[lineIPos][14] = pairs[q].o2;
//				lineI[lineIPos][15] = pairs[K].o2;
//				lineI[lineIPos][16] = pairs[J].o2;
//				lineI[lineIPos][17] = pairs[l].o2;
//				lineI[lineIPos][18] = pairs[D].o2;
//				lineI[lineIPos][19] = pairs[X].o2;
//				lineI[lineIPos][20] = pairs[M].o2;
//				lineI[lineIPos][21] = pairs[o].o2;
//				lineI[lineIPos][22] = pairs[j].o2;
//				lineI[lineIPos][23] = pairs[N].o2;
//				lineI[lineIPos][24] = pairs[p].o2;
//				lineI[lineIPos][25] = pairs[P].o2;
//				lineI[lineIPos][26] = pairs[O].o2;
//				lineI[lineIPos][27] = pairs[E].o2;
//				lineI[lineIPos][28] = pairs[L].o2;
//				lineI[lineIPos][29] = pairs[r].o2;
//				//printf("%ld: ", lineIPos);
//				for (int i = 0; i < 30; i++) {
//					fprintf(out1, "%d ", lineI[lineIPos][i]);
//					//printf("%d ", lineI[lineIPos][i]);
//				}
//				fprintf(out1, "\n");
//				//printf("\n");
//				lineIPos++;
//
//
//							count4++;
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//						}
//
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//					}
//
//		}
//		printf("**count4: %ld\n", count4);
//	}//OUTER
//	fclose(out1);
//	system("date");

	FILE *outfd = fopen("con_out", "w+");
/*
NWE: {7,13}, {7,16}, {14,28},
11 12
NOT: 
{7,13},
{14,28},
{14,29},
//////////
{7,13},
{9,18},
{14,28},
*/
	
int just[43][2] = 
{
{0,2},
{0,3},
{0,4},
{0,18},
{0,27},
{1,2},
{1,4},
{2,9},
{3,8},
{4,6},
{4,8},
{4,19},
{4,23},
{5,15},
{5,28},
{6,12},
{6,25},
{7,10},
{7,13},
{7,16},
{7,26},
{8,12},
{8,16},
{9,18},
{10,17},
{10,22},
{10,23},
{11,12},
{12,15},
{12,28},
{13,17},
{14,28},
{14,29},
{15,16},
{15,25},
{16,20},
{16,23},
{17,27},
{20,26},
{21,26},
{22,24},
{23, 25},
{23, 27}
};
//						if (pairs[g].o2 == pairs[i].o1) {
	printf("just len is %d\n", (int)sizeof(just)/(2* (int)sizeof(int)));

/*
	////////////SSSSSSSSSSSSSSSSSSSSSSSSS
map <pair<int, int>, pair<int, int>> simple;
	{
		for (int i = 0; i < 43; i++) {
			int one = just[i][0];	//0
			int two = just[i][1];	//2
						// bs to match 2 X and then orients of those two
			for (int q = 0; q < pairsPos; q++) {
				if (pairs[q].b1 == one && pairs[q].b2 == two) { //this matches the pair in just
	
					for (int r = 0; r < pairsPos; r++) {
						if (pairs[r].b1 == two) { // 2 or 0
							if (pairs[q].o2 == pairs[r].o1) {
								pair <int, int> p1;
								p1.first = pairs[r].b1;
								p1.second = pairs[r].b2;
								simple[{one, two}] = p1;
								//printf("bs -- one two match [%d,%d]\n", one, two);
							}
						}
						if (pairs[r].b1 == one) { // 2 or 0
							if (pairs[q].o2 == pairs[r].o1) {
								pair <int, int> p1;
								p1.first = pairs[r].b1;
								p1.second = pairs[r].b2;
								simple[{one, two}] = p1;
								//printf("bs -- one two match [%d,%d]\n", one, two);
							}
						}
					}
				}
			}
		}
	}
	printf("joins\n");
	for (auto it = simple.begin(); it != simple.end(); it++) {
	
		if (it->first.second == it->second.first && it->first.first != it->second.second) {
			printf("%d, %d == %d,%d\n", it->first.first, it->first.second, it->second.first, it->second.second);
		} else if (it->first.second == it->second.second && it->first.first != it->second.first) {
			printf("%d, %d == %d,%d\n", it->first.first, it->first.second, it->second.second, it->second.first);
		} else if (it->first.first == it->second.second && it->first.second != it->second.first) {
			printf("%d, %d == %d,%d\n", it->first.second, it->first.first, it->second.second, it->second.first);
		} else if (it->first.first == it->second.first && it->first.second != it->second.second) {
			printf("%d, %d == %d,%d\n", it->first.second, it->first.first, it->second.first, it->second.second);
		}
	}
	printf("end joins\n");
*/
/*
	for (int i = 0; i < 43; i++) {
		int one = just[i][0];	
		int two = just[i][1];	
		if (one == two) {continue;}
		for (int q = 0; q < pairsPos; q++) {
			for (int r = 0; r < pairsPos; r++) {
				if (pairs[q].b1 == one && pairs[r].b2 == two) {
					if (pairs[q].o1 == pairs[q].o2) {
						printf("bs -- one two match [%d,%d]\n", one, two);
					}
				}
			}
		}

		one = just[i][1];	
		two = just[i][2];	
		for (int q = 0; q < pairsPos; q++) {
			for (int r = 0; r < pairsPos; r++) {
				if (pairs[q].b1 == one && pairs[r].b2 == two) {
					if (pairs[q].o1 == pairs[q].o2) {
						printf("bs -- one two match [%d,%d]\n", one, two);
					}
				}
			}
		}
	}
*/

	printf("pairsPos %d\n", pairsPos);
	//printf("END -- for now...\n");
	long arPos = -1;

	printf("the business end\n");
	system("date");
	lineIPos = 0;
	FILE *uni = fopen("lineI.snip", "r");
	int lineI3[] = {0, 3, 16, 1, 15, 8, 2, 10, 5, 14, 4, 19, 12, 9, 18, 20, 23, 11, 22, 13, 17, 6, 21, 7, 22, 15, 23, 21, 8, 13};
//	while (1) {
//		fgets(line1, LINE-1, uni);
//		if (feof(uni)) break;
//		line1[strlen(line1)-1] = '\0';
//		
//		sscanf(line1, "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d", 
//			&lineI[lineIPos][0],	
//			&lineI[lineIPos][1],	
//			&lineI[lineIPos][2],	
//			&lineI[lineIPos][3],	
//			&lineI[lineIPos][4],	
//			&lineI[lineIPos][5],	
//			&lineI[lineIPos][6],	
//			&lineI[lineIPos][7],	
//			&lineI[lineIPos][8],	
//			&lineI[lineIPos][9],	
//			&lineI[lineIPos][10],	
//			&lineI[lineIPos][11],	
//			&lineI[lineIPos][12],	
//			&lineI[lineIPos][13],	
//			&lineI[lineIPos][14],	
//			&lineI[lineIPos][15],	
//			&lineI[lineIPos][16],	
//			&lineI[lineIPos][17],	
//			&lineI[lineIPos][18],	
//			&lineI[lineIPos][19],	
//			&lineI[lineIPos][20],	
//			&lineI[lineIPos][21],	
//			&lineI[lineIPos][22],	
//			&lineI[lineIPos][23],	
//			&lineI[lineIPos][24],	
//			&lineI[lineIPos][25],	
//			&lineI[lineIPos][26],	
//			&lineI[lineIPos][27],	
//			&lineI[lineIPos][28],	
//			&lineI[lineIPos][29]);
//		lineIPos++;
//
//	}
//	printf("lineIPos %ld\n", lineIPos);
//	fclose(uni);
restart:
	arPos++;
	//printf("arPos V lineIPos %ld V %ld\n", arPos, lineIPos);
	pairsPos = 0;
	//b1Q.push_back(b1);
	//////////////
	//if (f1 == 1) { next(var_orient); } else { f1 = 1; }
	allBPos = 0;


	//sets the first score...
	for (int two = 0; two < beacon[0].beaconPos; two++) {
		int found = 0;
		for (int z = 0; z < allBPos; z++) {
			if (allB[z].x == beacon[0].x[two][0] + beacon[0].mapx &&
					allB[z].y == beacon[0].y[two][0] + beacon[0].mapy &&
					allB[z].z == beacon[0].z[two][0] + beacon[0].mapz)  {
				found = 1;
				break;
			}
		}
		if (found == 0) {
			allB[allBPos].x = beacon[0].x[two][0] + beacon[0].mapx;
			allB[allBPos].y = beacon[0].y[two][0] + beacon[0].mapy;
			allB[allBPos].z = beacon[0].z[two][0]+ beacon[0].mapz;
			allBPos++;
		}
	}
	int var_tot = allBPos;
	for (int two = 0; two < beacon[0].beaconPos; two++) {
			mp2[{beacon[0].x[two][0], beacon[0].y[two][0], beacon[0].z[two][0]}] = 1;
	}
	printf("at Start: allBPos: %d\n", allBPos); getchar();

	for (int i = 0; i < beaconNum; i++) {
		for (int k = 0; k < 24; k++) {
			for (int j = 0; j < beacon[i].beaconPos; j++) {
				beacon[i].x[j][k] = beaconOrig[i].x[j][k];
				beacon[i].y[j][k] = beaconOrig[i].y[j][k];
				beacon[i].z[j][k] = beaconOrig[i].z[j][k];
			}
		}
	}
	beacon[0].scannerx = 0;
	beacon[0].scannery = 0;
	beacon[0].scannerz = 0;

	beacon[0].mapx = 0;
	beacon[0].mapy = 0;
	beacon[0].mapz = 0;

	beacon[0].orient = 0;

	for (int i = 1; i < beaconNum; i++) {
		beacon[i].scannerx = -999;
		beacon[i].mapx = -999;
		beacon[i].scannery = -999;
		beacon[i].mapy = -999;
		beacon[i].scannerz = -999;
		beacon[i].mapz = -999;
	}

	//CONCONCON
	
int b11_1[] =     {0, 0, 0,0, 0, 2,  9, 2, 1,  4, 4, 4, 3,  8, 4,  6, 23, -1, 25, 12, 15,  5, 23, 6, 10, 7, 26, 8, 10, 12, 15, 20, 16, 23, 20, 10, 27, 17, 12, 26, 22, 28, 14, 13, 16, 20, 26};
int b22_2[] =     {2, 3,4,18, 27, 9, 18, 1, 4, 19, 6, 8,8, 16, 23, 12, 25, -1, 15, 15,  5, 28, 10, 25, 7,16, 7, 12, 17, 28, 16, 16, 23, 27, 26, 22, 17, 13, 11, 21, 24, 14, 29, 7, 20, 26, 21};
	for (int b1_1Pos = 0; b1_1Pos < (int)sizeof(b11_1)/sizeof(int); b1_1Pos++) {
		int b1 = b11_1[b1_1Pos];
		int b2 = b22_2[b1_1Pos];
		if (b1 == -1 || b2 == -1) {continue;}
		{
			int o1;
			o1 = lineI3[b1];
			{
				int o2;
				{
					o2 = lineI3[b2];
					{
						//printf("beacon [%d] v [%d] -- [%d] V [%d]\n", b1, b2, o1,o2); //getchar();
						for (int p1b1 = 0; p1b1 < beacon[b1].beaconPos; p1b1++) {
							int most[100] = {0};
							int count = 0;
							for (int p2b1 = 0; p2b1 < beacon[b1].beaconPos; p2b1++) {
								if (p1b1 == p2b1) {continue;}
								for (int p1b2 = 0; p1b2 < beacon[b2].beaconPos-1; p1b2++) {
									alPos = 0;
									for (int p2b2 = p1b2+1; p2b2 < beacon[b2].beaconPos; p2b2++) {
                                                                                if (p1b2 == p2b2) {continue;}
										//if (b1 == 0 && b2 == 3 && o1 == 0 && o2 == 0) {goto start123;}
                                                                                int found4 = 0;
                                                                                for (int q = 0; q < alPos; q++) {
                                                                                        if (((al[q].p1b2 == p1b2) && (al[q].p2b2 == p2b2)) || ((al[q].p1b2 == p2b2)  && (al[q].p2b2 == p1b2))) {
                                                                                                found4 = 1;
                                                                                                break;
                                                                                        }
                                                                                }
                                                                                if (found4 == 0) {
                                                                                        al[alPos].p1b2 = p1b2;
                                                                                        al[alPos].p2b2 = p2b2;
                                                                                        alPos++;
                                                                                } else {
                                                                                        continue;
                                                                                }

										if (beacon[b1].distxx[o1][p1b1][p2b1]  == beacon[b2].distxx[o2][p1b2][p2b2] &&
												beacon[b1].distyy[o1][p1b1][p2b1] == beacon[b2].distyy[o2][p1b2][p2b2] &&
												beacon[b1].distzz[o1][p1b1][p2b1] == beacon[b2].distzz[o2][p1b2][p2b2]) {
					
											
											tmpxyz[count].b1 = b1;
											tmpxyz[count].pos1 = p1b1;
											tmpxyz[count].pos_1 = p2b1;
											tmpxyz[count].o11 = o1;

											tmpxyz[count].b2 = b2;
											tmpxyz[count].pos2 = p1b2;
											tmpxyz[count].pos_2 = p2b2;
											tmpxyz[count].o22 = o2;

											count++;
											most[p1b2]++;
											most[p2b2]++;

											//printf("found [[count:%d]] b1:%d o1:%d p1b1:%d p2b1:%d V b2:%d o2:%d p1b2:%d p2b2:%d [%d V %d]\n", count, b1, o1, p1b1, p2b1, b2, o2, p1b2, p2b2, o1, o2);

											if (b1 == 0 && b2 == 3) {
												//printf("count: %d\n", count); //getchar();
											}
											if (count == 11) {
												printf("(%ld) 11: b1:%d b2:%d o1:%d o2:%d\n", arPos, b1, b2, o1, o2); //getchar();
												int max = 0;
												int maxI = -1;
												for (int i = 0; i < 30; i++) {
													if (most[i] > max) {max = most[i]; maxI = i;}
												}


												//printf("COUNT11: maps: %d %d %d V %d %d %d\n", beacon[b1].scannerx, beacon[b1].scannery, beacon[b1].scannerz,
												//		beacon[b2].scannerx, beacon[b2].scannery, beacon[b2].scannerz); fflush(stdout);
												if (beacon[b1].scannerx == -999 && beacon[b1].scannery == -999 && beacon[b1].scannerz == -999) {
													printf("ERROR b1 not filled ->start123----\n"); getchar(); goto start123;
												} else {
													printf("b1 filled\n");
												}
												if (beacon[b2].scannerx == -999 && beacon[b2].scannery == -999 && beacon[b2].scannerz == -999)  {
													printf("b2 not filled -- aok\n");
												} else {
													printf("ERROR b2 filled %d,%d ->start123-----\n",b1, b2); getchar(); goto start123;
												}

												//printf("allBPos now %d\n", allBPos); fflush(stdout);
												for (int r = 0; r < 11; r++) {
													tmpxyz[r].b11 = b1;
													tmpxyz[r].o11 = o1;
													tmpxyz[r].b22 = b2;
													tmpxyz[r].o22 = o2;
													tmpxyz[r].p1 = tmpxyz[r].pos_1;
													tmpxyz[r].p2 = tmpxyz[r].pos_2 == maxI ? tmpxyz[r].pos2 : tmpxyz[r].pos_2;
												}
												for (int r = 0; r < 11; r++) {
													//printf("r:%d p1,p2 == %d,%d\n", r, tmpxyz[r].p1, tmpxyz[r].p2);
													tmpxyz[r].mapx = beacon[b1].x[tmpxyz[r].p1][o1] - beacon[b2].x[tmpxyz[r].p2][o2];
													tmpxyz[r].mapy = beacon[b1].y[tmpxyz[r].p1][o1] - beacon[b2].y[tmpxyz[r].p2][o2];
													tmpxyz[r].mapz = beacon[b1].z[tmpxyz[r].p1][o1] - beacon[b2].z[tmpxyz[r].p2][o2];
												}

												int found2 = 0;
												for (int r = 0; r < 11-1; r++) {
													if (tmpxyz[r].mapx == tmpxyz[r+1].mapx && tmpxyz[r].mapy == tmpxyz[r+1].mapy &&
															tmpxyz[r].mapz == tmpxyz[r+1].mapz) {
													} else {
														//printf("first %d\n", r);
														found2 = 1;
														break;
													}
												}

												int xmain = beacon[b1].x[p1b1][o1] - beacon[b2].x[maxI][o2]; 
												int ymain = beacon[b1].y[p1b1][o1] - beacon[b2].y[maxI][o2];
												int zmain = beacon[b1].z[p1b1][o1] - beacon[b2].z[maxI][o2];
												if (found2 == 0) {
													//printf("most maps same -- checking last one\n");
													if (xmain == tmpxyz[0].mapx && ymain == tmpxyz[0].mapy && zmain == tmpxyz[0].mapz) {
														found2 = 0;
													} else {
														found2 = 1;
													}
												}
												if (found2 == 0) {
													//beacon[b2].orient = o2;
													//printf("setting orient for beacon:%d to %d\n", b2, beacon[b2].orient); //getchar();
													//printf("ALL SAME COUNT11: orient: %d V %d\n", o1, o2); //getchar();

													printf("MAPS all same b1:%d b2:%d\n", b1, b2); getchar();
													//printf("setting scanner for %d\n", b2);
													beacon[b2].scannerx = tmpxyz[0].mapx;
													beacon[b2].scannery = tmpxyz[0].mapy;
													beacon[b2].scannerz = tmpxyz[0].mapz;
													//printf("SAME [[arPos:%ld]] b:[%d,%d] map:[%d %d %d] o:[%d][%d]\n", arPos,
													//		b1, b2, tmpxyz[0].mapx, tmpxyz[0].mapy, tmpxyz[0].mapz, o1, o2);

													for (int one = 0; one < beacon[b2].beaconPos; one++) {
														int found = 0;
														for (int z = 0; z < allBPos; z++) {
															if (allB[z].x == beacon[b2].x[one][o2] + tmpxyz[0].mapx &&
																	allB[z].y == beacon[b2].y[one][o2] + tmpxyz[0].mapy &&
																	allB[z].z == beacon[b2].z[one][o2] + tmpxyz[0].mapz) {
																found = 1;
																break;
															}
														}
														if (found == 0) {

															allB[allBPos].x = beacon[b2].x[one][o2] + tmpxyz[0].mapx;
															allB[allBPos].y = beacon[b2].y[one][o2] + tmpxyz[0].mapy;
															allB[allBPos].z = beacon[b2].z[one][o2] + tmpxyz[0].mapz;
															//printf("adding %d %d %d map: %d %d %d\n", allB[allBPos].x, allB[allBPos].y, allB[allBPos].z,
															//		beacon[b2].mapx, beacon[b2].mapy, beacon[b2].mapz);
															allBPos++;
															beacon[b2].x[one][o2] = beacon[b2].x[one][o2] + tmpxyz[0].mapx;
															beacon[b2].y[one][o2] = beacon[b2].y[one][o2] + tmpxyz[0].mapy;
															beacon[b2].z[one][o2] = beacon[b2].z[one][o2] + tmpxyz[0].mapz;
														} else {
															//printf("NOT adding %d %d %d map: %d %d %d\n", allB[allBPos].x, allB[allBPos].y, allB[allBPos].z,
															//		beacon[b2].mapx, beacon[b2].mapy, beacon[b2].mapz);
															beacon[b2].x[one][o2] = beacon[b2].x[one][o2] + tmpxyz[0].mapx;
															beacon[b2].y[one][o2] = beacon[b2].y[one][o2] + tmpxyz[0].mapy;
															beacon[b2].z[one][o2] = beacon[b2].z[one][o2] + tmpxyz[0].mapz;
															var_tot++;
														}
													}
													printf("(%ld) %d,%d: allBPos: %d\n", arPos, b1, b2, allBPos);///getchar();
													for (int thr = 0; thr < beacon[b2].beaconPos; thr++) {
														mp2[{beacon[b2].x[thr][o2], beacon[b2].y[thr][o2], beacon[b2].z[thr][o2]}] = 1;
													}

													count = 0;
													//pairs[pairsPos].b1 = b1; pairs[pairsPos].b2 = b2; pairsPos++;
													goto start123;
												} else {
													printf("MAPS NOT SAME b1: %d b2: %d --  o1:%d o2:%d\n", b1, b2, o1, o2); getchar();
													goto start123;
													//goto end;
													///////////////goto end;											
												}

											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
start123:
		continue;

	}
end:
	/*
	   for (int i = 0; i < beaconNum; i++) {
	   printf("scanner: %d => %d %d %d\n", i, beacon[i].scannerx, beacon[i].scannery, beacon[i].scannerz);	
	   }
	 */
	int found4 = 0;

	printf("arPos: %ld\n", arPos);
	for (int i = 0; i < beaconNum; i++) {
		if (beacon[i].scannerx == -999 && beacon[i].scannery == -999 && beacon[i].scannerz == -999) {
		} else {
			if (i == 3) {printf("b == 3 wahey\n"); getchar();} else 
			if (i == 18) {printf("b == 18 wahey\n"); getchar();} else
			if (i == 27) {printf("b == 27 wahey\n"); getchar();}
			printf("scanner not 0 or -999: (%ld) %d: %d %d %d\n", arPos, i, beacon[i].scannerx, beacon[i].scannery, beacon[i].scannerz);
		}
	}
	printf("-------------\n"); //getchar();

	for (int i = 0; i < beaconNum; i++) {
		if (beacon[i].scannerx == -999 && beacon[i].scannery == -999 && beacon[i].scannerz == -999) {
			found4 = 1;
			break;
		}
	}
	if (found4 == 0) {
		fprintf(outfd, "good run**allBPos is %d \n", allBPos);
		printf("good run**allBPos is %d \n", allBPos);
	}
	if (arPos+1 >= lineIPos) {
		printf("ENDP %ld V %ld \n", arPos+1, lineIPos);
	} else {
		printf("**allBPos is %d\n", allBPos);
		//goto restart;
	}
	//if (strcmp(var_orient, "NNNNN") != 0) { //printf("going to restart...\n"); goto restart; }
	//printf("%s %d\n", var_orient, allBPos);
	system("date");
	printf("** ans %d\n", (int)mp2.size());
	int subtot = 0;
	for (int i = 0; i < beaconNum; i++) {
		subtot += beacon[i].beaconPos;
	}
	subtot -= allBPos;
	map <tuple<int, int, int>, int> mp3;
	for (int zz = 0; zz < beaconNum; zz++) {
		for (int thr = 0; thr < beacon[zz].beaconPos; thr++) {
			mp3[{beacon[zz].x[thr][lineI3[zz]], beacon[zz].y[thr][lineI3[zz]], beacon[zz].z[thr][lineI3[zz]]}] = 1;
		}
	}
	printf("**mp3.size %d\n", (int)mp3.size()); fflush(stdout);

	printf("Thats a wrap -- %d\n", subtot); fflush(stdout);
	printf("**ans %d\n", (int)mp2.size()); fflush(stdout);
	printf("**var_tot %d\n", (int)var_tot); fflush(stdout);
	fclose(outfd);

}


int numit(int pos) {
	/*
	   switch(var_orient[pos]) {
	   case '0':
	   case '1':
	   case '2':
	   case '3':
	   case '4':
	   case '5':
	   case '6':
	   case '7':
	   case '8':
	   case '9': return var_orient[pos] - 48;
	   case 'A':
	   case 'B':
	   case 'C':
	   case 'D':
	   case 'E':
	   case 'F':
	   case 'G':
	   case 'H':
	   case 'I':
	   case 'J':
	   case 'K':
	   case 'L':
	   case 'M':
	   case 'N': return var_orient[pos] - 55;
	   default:
	   perror("ERR numit"); exit(0);
	   }
	 */
	return 0;
}
void next(char *s) {

	//for(s+=10;*--s>89;)*s=48;*s+=*s-57?1:8;	
	//for(aS+=5;*--aS>77;)*aS=48;*aS+=*aS-57?1:8;	
	//worksfor10{for(s+=9;(*s+=*s-57?1:8)>90;*s--=48);}
	{for(s+=9;(*s+=*s-57?1:8)>78;*s--=48);}
	//for(as+=;(*as+=*as-57?1:8)>90;*as--=48);

	//aI++;
	//sprintf(aS, "%05d", aI);
}

void matmul(int ma[3][3], int threebyone[3], int beaconPos, int jpos, int pos) {

	beacon[beaconPos].x[jpos][pos] = 0;
	beacon[beaconPos].y[jpos][pos] = 0;
	beacon[beaconPos].z[jpos][pos] = 0;
	int result[3] = {0};
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			if (i == 0) {
				beacon[beaconPos].x[jpos][pos] += ma[i][j] * threebyone[j];
			} else if (i==1) {
				beacon[beaconPos].y[jpos][pos] += ma[i][j] * threebyone[j];
			} else if (i==2) {
				beacon[beaconPos].z[jpos][pos] += ma[i][j] * threebyone[j];
			}
			result[i] +=  ma[i][j] * threebyone[j];
		}
	}
	assert(result[0] ==  beacon[beaconPos].x[jpos][pos]);
	assert(result[1] ==  beacon[beaconPos].y[jpos][pos]);
	assert(result[2] ==  beacon[beaconPos].z[jpos][pos]);
}

void dfs(int u, vector<int>& cur_group) {
    if (vis.count(u)) return;
    vis.insert(u);
    cur_group.push_back(u);
    for (auto v: adj[u]) {
        dfs(v, cur_group);
    }
};

int pairZ() {
//    vector<pair<int, int>> input = {{4,3},{1,9},{7,9},{2,4},{3,2},{9,7},{9,9}};
vector <pair<int,int>> input = 
{
{0,2},
{2,0},
{0,3},
{3,0},
{0,4},
{4,0},
{0,18},
{18,0},
{0,27},
{27,0},
{1,2},
{2,1},
{1,4},
{4,1},
{2,9},
{9,2},
{3,8},
{8,3},
{4,6},
{6,4},
{4,8},
{8,4},
{4,19},
{19,4},
{4,23},
{23,4},
{5,15},
{15,5},
{5,28},
{28,5},
{6,12},
{12,6},
{6,25},
{25,6},
{7,10},
{10,7},
{7,13},
{13,7},
{7,16},
{16,7},
{7,26},
{26,7},
{8,12},
{12,8},
{8,16},
{16,8},
{9,18},
{18,9},
{10,17},
{17,10},
{10,22},
{22,10},
{10,23},
{23,10},
{11,12},
{12,11},
{12,15},
{15,12},
{12,28},
{28,12},
{13,17},
{17,13},
{14,28},
{28,14},
{14,29},
{29,14},
{15,16},
{16,15},
{15,25},
{25,15},
{16,20},
{20,16},
{16,23},
{23,16},
{17,27},
{27,17},
{20,26},
{26,20},
{21,26},
{26,21},
{22,24},
{24,22},
{23,25},
{25,23},
{23,27},
{27,23}
};

    // create undirected graph
    for (auto [u, v]: input) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    int component_count = 0;
    unordered_map<int, int> color;
    // traverse all nodes and color all nodes reachable.
    for (auto [u, v]: input) {
        // If u is traversed v must be traversed as they are adjacent
        if (vis.count(u) == 0) {
            vector<int> cur_group;
            dfs(u, cur_group);
            for (int v: cur_group) {
                color[v] = component_count;
            }
            component_count++;
        }
    }

    // push input pairs into their corresponding color component
    vector<vector<pair<int, int>>> components(component_count);
    for (auto p: input) {
        components[color[p.first]].push_back(p);
    }

    // sort and output each color component separately
    for (auto& component: components) {
        sort(component.begin(), component.end());
        for (auto [u, v]: component) {
            cout << '(' << u << ',' << v << "),";
        }
        cout << endl;
    }

    return 0;
}
